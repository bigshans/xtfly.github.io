<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cpp on 蘭陵N散記</title>
    <link>http://lanlingzi.cn/tags/cpp/index.xml</link>
    <description>Recent content in Cpp on 蘭陵N散記</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <atom:link href="http://lanlingzi.cn/tags/cpp/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Go/Java/C&#43;&#43;杂谈</title>
      <link>http://lanlingzi.cn/post/technical/2016/0702_go_cpp_java/</link>
      <pubDate>Sat, 02 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2016/0702_go_cpp_java/</guid>
      <description>&lt;p&gt;最近公司层面在摧广Go语言，我作为平台DU的首席编程，参加其中一些讨论。虽有5年+的C++开发经验，也有5年+的Java开发经验，Go差不多也有2年时间。但个人仍觉得语言不是解决业务问题的银弹，换种语言也不可能就能提升开发效率。从语言层面来说，各种语言都有它们的优缺点，有不同的使用场景；而一个语言是否能大规模应用，往往是它的整个生态。个人虽比较喜欢Go，但从目前刚兴起的生态来看，也不敢在产品中大面积推广它。下面就从各语言概要来说说他们。&lt;/p&gt;

&lt;h2 id=&#34;go&#34;&gt;Go&lt;/h2&gt;

&lt;p&gt;首先要肯定的，Go语言在并发方面，goroutine与channel机制提供了语言层面的轻量组的并发机制，使得并发编程变得较为简单；在性能方面，由于它直接编译为机器码，提供了据说超过Java的运行性能（1.6版本在计算方面部分已超过Java）；在内存资源点用方面，相对Java或其它带有虚拟机的语言来说，具备明显的优势；在语法方面，继承了C的简洁，严谨的编码要求，以及吸收像Python动态语言特性，在对象构建，序列化提供简洁的表态方式，而这些代码可能占据10%~20%的代码量，尤其对于处理数据，配置，协议映射场景下，相比C/C++在此方面笨拙，这就是动态语言为何让人着迷的地方。
&lt;/p&gt;

&lt;p&gt;这也是为什么Go语言一发布时就如此受人瞩目的关键原因，尤其是对于动态语言来说，这提供了动态语言所不具有的并发与性能优势。Go主创人员设计语言的目的是解决原来C/C++大工程编译慢，维护困难的问题，作为其另外一个可选的角色。Pike 12年“大道至简”演讲稿中对此目标充满沮丧，引用其中一名话：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Although we expected c++ programmers to see Go as an alternative, instead most Go programmers come from languages like Python and Ruby. Very few come from C++.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;C++的价值精髓在于：语言提供更加广泛的抽象，优雅和灵活的特性，而这些表达能力是硬件零成本的。而Go思考的方向显示不是零成本，至少不是零CPU成本，Go的主张更多考虑的是最小化程序员的工作量。&lt;/p&gt;

&lt;p&gt;一个是硬件零成本的极致追求，一个是最小程序员的工作量，谁都替换不了谁最最价值的部分。Go无法同时符合两个目标，选择了动态语法与GC，就注定了选择开发效率，会为开发效率牺牲硬件效率，所以它走向另外一个方向，也就是目前Java所擅长的应用方向，尤其是目前的网络与WEB应用方面，这就需要有良好的标准库和生态系统支持。在标准方面，Go已提供了处理tcp/http/json/crypto/image等方面的标准库，它对网络的核心协议HTTP高并发支持，已经开发在抢Java的地盘了。&lt;/p&gt;

&lt;p&gt;Go目前在分布系统，WEB应用，云计算云平台开始显示出优势，但是我们也必须看到它的不足，Go在创业公司与互联网企业应用越来眼越多，但在企业级还是未看到成功的案例。最重要的原因可能是其语言重要特性与工业工具还远未成熟，还有不少的断层或临时解决方案。但Go这两年来，在开源界发展速度，生态也会越来越成熟。在Go编译与Runtime也是在多个版本不断地优化与调整。Go于12年发布第一个版本，截止目前的1.7 beta版本发布，差不多是一年两个大版本，对于语言级，每年的版本发布可能会让大企业选择它犹豫再三，不敢应在极核心业务领域，担心它的不稳定带来商用风险不可控。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Go已证明在动态语言需要性能，是作为Python与Ruby的理想候选者。在生产方面，其语言特性与生态系统还远没有像Python与Java成熟，目前阶段也是只在某些场景下的可选角色，从长期来看，在Google的战略支持下，肯定越来越蚕食Python与Java等带有GO与动态性的语言地盘。但在C/C++擅长的领域，尤其是要求实时性，CPU密集计算的领域，短期Go还无法渗入。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;java&#34;&gt;Java&lt;/h2&gt;

&lt;p&gt;Java的成功，10年前靠Unix系统的SUN/IBM/Oracle的强国支撑让它在企业应用领域和WEB应用方面站稳了脚跟；而随后的10年，前半段是靠x86+Linux带来的革命继续保持份额，后半段依托于Android的成功让其在步履蹒跚停止脚步后再一次登顶。二十多年，Java积累了最大的生态系统，可以说它是无说不包，已是一艘航空母舰，足已证明它的地址与成功。但是在其语言、库、框架与生态的复杂度，对技术的人员来说，Java已不太简单，已构成巨大的障碍。比如在Go擅长的并发，语言层面有synchronized机制，标准库的lock与notify，再到后来的concurrent库。基于JVM，Java又可以与其它语言具有良好的互操作性，如并发方面的Scala，可以选择Actor或Akka。&lt;/p&gt;

&lt;p&gt;Java的世界轮子太多，你需要重复造轮子，也是Java成功的关键之一，历史沉淀下来让Java选择太多，也显著增加成本。深入后Java的学习成功可以比C++更高，技术人员需要非常精心地组织框架与设计，否则各种复用的结果就是堆砌出一个异常臃肿的程序，其运行时对资源的消耗有时候会让你感到恐惧，而这是太多的基于Java所开发的平台被广泛诟病的重要原因之一。复用是一把双刃剑，是要量体裁衣还是一锅端，拿捏的尺度对于开发人员要求无疑是高昂的。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Java已是无所不包，近十年基本都是排名最好的语言，积累最强大的生态。但其众多的框架，库复杂度也远不是让一个普通程序员能轻易掌握的，拿捏不好也将是一场灾难。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;c-c&#34;&gt;C/C++&lt;/h2&gt;

&lt;p&gt;C/C++在嵌入式和系统编程方面，依然占据差牢固地位，但是在并发、网络和应用编程等方面，一直处于讳莫如深的黑暗时代，语言本身未提供任何支持，而太单薄的标准库也毫无此方面的野心，C/C++的标准库的规模恐怕始终无法比拟Java/Go，因为C/C++不受任何一家大型商业公司控制，而是完全片处于“放养“状态。标准库需要得到大型商业公司持续的投资，这就是为什么C++98标准库在13年后才获得一次大的更新。C/C++需要封装各种硬件平台的系统API，而linux+x86大面积击败Unix之前，众多的Unix系统更加剧了跨平台编程的难度。2000年左右出现跨平台的ACE库，还有Win平台上MFC库，都是糟糕难用，所以也没有大规模地成功，反而成了当时程序员的救命草，显然，这些技术已被历史所丢弃。而同时期Java原生提供了多线程，网络的标准库，以及基于JVM技术的跨平台支持，把Java推向了主流语言。&lt;/p&gt;

&lt;p&gt;对于C/C++程序员，有一个振奋人心的大事件，C++11发布，相比C++98，无论在语言和标准库上，都是一个极大飞跃。C++之父说它是一门新语言，这不为过，同时如此多的顶尖C++高手对boost库的贡献，它也是事实上的标准库，在网络、并发编程和一些基本应用方面，已经提供了性能优秀的库，极大地降低了此方面的开发难度。传统的C++程序员，须尽快过渡到C++11上，这需要编译环境的更新，而编译环境更新又会带来内存检测和性能分析方面最强力的工具。C/C++曾经最广泛的内存越界与泄露总是，在GCC5.2版本与Intel最新CPU面前，内存飞踩可参被抓在第一现场，同时Intel提供的vtune性能分析工具，足也解决绝大多数的问题。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;传统C++程序员，须尽快拥抱C++11，新的标准库，Boost库，这会极大提高开发与维护效率。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;技巧之名字空间namespace</title>
      <link>http://lanlingzi.cn/post/technical/csdn/cpp_namespace_usage/</link>
      <pubDate>Mon, 13 Jul 2009 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/csdn/cpp_namespace_usage/</guid>
      <description>&lt;p&gt;C开发人员会经常使用&lt;code&gt;#define&lt;/code&gt;即宏来声明常量，但宏却是全局的，对大的工程来说是很难维护，经常是导致名字冲突。还好，C++给我们带来了&lt;code&gt;namespace&lt;/code&gt;名字空间。它的使用如下，名字空间可以把一组逻辑分组，同时名字空间也是一种作用域。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;namespace outspname  
{   
   const int CVAR1 = 1;  
   const char* const CVAR2 = &amp;quot;33333&amp;quot;;  
   void test();  

   namespace inspname  
   {  
      enum { A, B, C};  
      class Klass  
      {  
      };  
   }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但即使一个简单的名字空间，其中也有不少的玄机。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;当某个名字在自己的空间之外使用，在反复地在前面加上名字空间作为限定词， 如:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const int  local  = outspname::inspname::A
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样写是不是很令人烦。在某个小的局部作用域内，我们可以通过一个使用声明。如:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{  
   using outspname::inspname::A;  
   const int local = A;  
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通过一个使用指令把该名字空间下所有的名字变成可用。&lt;/p&gt;

&lt;p&gt;如下所示，与第一点的用法区别，是&lt;code&gt;using&lt;/code&gt; 后面有个&lt;code&gt;namespace&lt;/code&gt;。同样只在转换时，或者在一个小的局部作用域内使用&lt;code&gt;using namesapce&lt;/code&gt;，否则也会带来名字的污染。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{  
  using namespace outspname;  
  const int local2 = CVAR1;  
  const int local2 = inspname::B;  
  {  
     using namespace inspname;  
     Klass* p = new Klass();  
  }    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但使用&lt;code&gt;using namespace&lt;/code&gt;这种用法时，要注意下面一点，如在某个.h中声明了有&lt;code&gt;testname::test&lt;/code&gt;的方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;namespace testname  
{  
   void test(int param);  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在其.cpp中，不能使用如下这种方式，test方法只是此编译单元的一个局部方法，并非testname名字空间的test方法实现。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using testname;  
void test(int param)  
{  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正确的使用方式是:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;namespace testname  
{  
   void test(int param)  
   {  
   }  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void testname::test(int param)  
{  
}  
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;名字空间的别名，当名字空间很长或嵌套很深时，我们可以使用名字空间别名，用法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;namespace oin = outspname::inspname;  
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;无名名字空间，无名名字空间主要是保持代码的局部性，使用如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;namespace   
{  
  const int CVAR1 = 1;  
  void test();  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但一定要注意的一点是，在C++编译器实现时，无名名字空间其实是有名字的，这个隐含的名字跟它所在编译单元名字相关。所以基于这一点，我们不能跨编译单元使用无名名字空间中的名字。上面的声明等价于:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;namespace $$$  
{  
  const int CVAR1 = 1;  
  void test();  
}

using namespace $$$;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;$$$&lt;/code&gt;在其所在的作用域里具有惟一性的名字，每个编译单元里的无名名字空间也是互不相同的，&lt;code&gt;usingnamesapce  $$$&lt;/code&gt;只是当前的编译单元的隐含名字，所以不能跨编译单元使用无名名字空间中的名字。假设上面的test方法在是a.h与a.cpp中定义与实现的，但在b.h或b.cpp中就不能直接使用test方法或CVAR1。因为在b的这个编译单元中链接的是b这个编译单元中的test符号，并非a编译单元中的test符号，也就会出现未定符号。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;要避免名字空间使用很短的名字，也不能太长，更不能嵌套太深了，个人觉得不要超过4层。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;] STL容器中erase方法的不同陷阱</title>
      <link>http://lanlingzi.cn/post/technical/csdn/cpp_erase_fault/</link>
      <pubDate>Wed, 01 Jul 2009 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/csdn/cpp_erase_fault/</guid>
      <description>

&lt;p&gt;&lt;code&gt;STL&lt;/code&gt;中的容器都有&lt;code&gt;erase&lt;/code&gt;方法，容器的存储分为顺序存储(如&lt;code&gt;vector&lt;/code&gt;)与链式存储(如&lt;code&gt;list,map&lt;/code&gt;)。先以&lt;code&gt;map&lt;/code&gt;为例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typedef std::map&amp;lt;std::string, std::string&amp;gt; TStrMap;  
typedef TStrMap::iterator TStrMapIter;  
TStrMap strmap;  
TStrMapIter iter = strmap.find(&amp;quot;somekey&amp;quot;);  
strmap.erase(iter);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样使用&lt;code&gt;erase&lt;/code&gt;方法没有任何问题，删除一个单结节之后，&lt;code&gt;stl&lt;/code&gt;中的&lt;code&gt;iterator&lt;/code&gt;都是与其中的数据元素关联的，关联的元素删除之后，&lt;code&gt;ite&lt;/code&gt;r已就失效，&lt;code&gt;iter&lt;/code&gt;理解为指向元素的指针，那删除之后可以简单理解为已是一个野指针。&lt;/p&gt;

&lt;p&gt;但有时我们一不注意，却会这样使用，这是错误的:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for(TStrMapIter iter= strmap.begin(); iter!= strmap.end();++iter)  
{  
   if (&amp;quot;somevalue&amp;quot; == iter-&amp;gt;second )  
   {  
     strmap.erase(iter);  
   }  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;iter&lt;/code&gt;所指的元素删除之后，&lt;code&gt;++iter&lt;/code&gt;是错误的，会导致程序的未知结果，&lt;code&gt;iter&lt;/code&gt;一般是不会移到指向下一个元素。&lt;/p&gt;

&lt;p&gt;对于&lt;code&gt;map&lt;/code&gt;与&lt;code&gt;list&lt;/code&gt;这样的链式存储结构。我们一般可以有两种解决办法:&lt;/p&gt;

&lt;h5 id=&#34;方法一&#34;&gt;方法一&lt;/h5&gt;

&lt;p&gt;使用&lt;code&gt;erase(iter++)&lt;/code&gt;，因为&lt;code&gt;iter2 = iter++&lt;/code&gt;是&lt;code&gt;iter&lt;/code&gt;先移到指向下一个节点，而&lt;code&gt;iter2&lt;/code&gt;还是指向当前的节点。注意理解&lt;code&gt;iter++&lt;/code&gt;与&lt;code&gt;++iter&lt;/code&gt;的区别。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for(TStrMapIter iter= strmap.begin(); iter!= strmap.end();)  
{  
   if (&amp;quot;somevalue&amp;quot; == iter-&amp;gt;second )  
   {  
     strmap.erase(iter++);  
   }  
   else  
   {  
     ++iter;   
   }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;方法二&#34;&gt;方法二&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;erase&lt;/code&gt;的返回值会指向下一个节点，记把下一节点赋给一个变量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for(TStrMapIter iter= strmap.begin(); iter!= strmap.end();)  
{  
   if (&amp;quot;somevalue&amp;quot; == iter-&amp;gt;second )  
   {  
     iter = strmap.erase(iter);  
   }  
   else  
   {  
     ++iter;  
   }  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但对于顺序存储的vector也可以使用上述两种方法吗？很遗憾，第一种用法却是错误的，但第二种用法是正确的。因为顺序存储的容器一旦erase时，会涉及到数据移动，iterator所指的位置还是那个位置，但元素却移动了，iter++之后已不再你想要的元素位置了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void test_vector_erase()  
{  
    typedef std::vector&amp;lt;int&amp;gt; TIntVec;  
    typedef TIntVec::iterator TIntVecIter;  
    TIntVec vec;  

    vec.push_back(1);  
    vec.push_back(2);  
    vec.push_back(3);  
    vec.push_back(4);  

    for (TIntVecIter iter = vec.begin(); iter != vec.end();)  
    {  
        std::cout &amp;lt;&amp;lt; *iter &amp;lt;&amp;lt; std::endl;  
        if (0 == *iter % 2)  
        {  
            vec.erase(iter++);  
        }  
        else  
        {  
            ++iter;  
        }  
    }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它输出的结果却是未知的，我的测试环境为&lt;code&gt;&amp;quot;1，2，4，4&amp;quot;&lt;/code&gt;。你可能发现原因，当删除&lt;code&gt;2&lt;/code&gt;元素时，&lt;code&gt;3&lt;/code&gt;往前移了，而&lt;code&gt;iter++&lt;/code&gt;不是指到&lt;code&gt;3&lt;/code&gt;，还是指到&lt;code&gt;4&lt;/code&gt;了。当你使用&lt;code&gt;STL&lt;/code&gt;容器中&lt;code&gt;erase&lt;/code&gt;方法，那是一定要小心再小心，我也是被它戏弄了一下之后，才明白其中容易被忽视的这些细节。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>C&#43;&#43;的仿函数与动态语言的闭包</title>
      <link>http://lanlingzi.cn/post/technical/csdn/cpp_closure_pkg/</link>
      <pubDate>Mon, 29 Jun 2009 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/csdn/cpp_closure_pkg/</guid>
      <description>&lt;p&gt;什么是闭包，我们先来用&lt;code&gt;ruby&lt;/code&gt;看个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sum = 0  
10.times{|n| sum += n}   
print sum
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;{}&lt;/code&gt;就是闭包的内容，代码看起来是不是很清爽与简单。&lt;/p&gt;

&lt;p&gt;我们还来看看&lt;code&gt;Python&lt;/code&gt;写的闭包：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def addx(x):      
    return lambda y: x + y  
add8 = addx(8)  
print add8(100)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用Python写就没有那么好看。&lt;/p&gt;

&lt;p&gt;闭包（Closure）是词法闭包（Lexical Closure）的简称。对闭包的具体定义有很多种说法，这些说法大体可以分为两类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一种说法认为闭包是符合一定条件的函数，闭包是在其词法上下文中引用了自由变量的函数。&lt;/li&gt;
&lt;li&gt;另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。比如参考资源中就有这样的的定义：在实现深约束时，需要创建一个能显式表示引用环境的东西，并将它与相关的子程序捆绑在一起，这样捆绑起来的整体被称为闭包。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这两种定义在某种意义上是对立的，一个认为闭包是函数，另一个认为闭包是函数和引用环境组成的整体。虽然有些咬文嚼字，但可以肯定第二种说法更确切。闭包只是在形式和表现上像函数，但实际上不是函数。函数是一些可执行的代码，这些代码在函数被定义后就确定了，不会在执行时发生变化，所以一个函数只有一个实例。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。所谓引用环境是指在程序执行中的某个点所有处于活跃状态的约束所组成的集合。其中的约束是指一个变量的名字和其所代表的对象之间的联系。那么为什么要把引用环境与函数组合起来呢？这主要是因为在支持嵌套作用域的语言中，有时不能简单直接地确定函数的引用环境。&lt;/p&gt;

&lt;p&gt;什么是仿函数，我们先用C++来写个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct comparer {  
  bool operator()(int a, int b) const {  
     return a &amp;gt; b;  
  }  
};  

int main(int, char**)  
{  
   std::vector&amp;lt;int&amp;gt; vec;  
   std::sort(vec.begin(), vec.end(), comparer());  
   return 0;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数(functor)之所以称为仿函数，是因为这是一种利用某些类对象支持&lt;code&gt;operator()&lt;/code&gt;的特性，来达到模拟函数调用效果的技术。从上面你也可以看出来，仿函数实现的内容其实就像动态语言闭包实现的方式差不多，形式不一样，效果是一样的。至于语言本质是什么，就让语言学家去争论吧。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>C&#43;&#43;技巧之栈变量的析构应用</title>
      <link>http://lanlingzi.cn/post/technical/csdn/cpp_stack_usage/</link>
      <pubDate>Thu, 25 Jun 2009 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/csdn/cpp_stack_usage/</guid>
      <description>

&lt;p&gt;栈变量有一个好处，就是它退栈时会自动析构，并且在栈上对象生成比在堆上分配效率高很多。但每个线程的栈空间是有限的(创建线程时可以设置)，所以一般的临时小对象都会在栈上分配。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Test {};  

void test()  
{  
    Test stack_var; // a stack var;  
    Test stack_var2; //a stack var;  
    int *heap_var = new int; // a heap var  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述的例子，&lt;code&gt;stack_var&lt;/code&gt;与&lt;code&gt;stack_var2&lt;/code&gt;都是一个栈变量，当然&lt;code&gt;stack_var&lt;/code&gt;与&lt;code&gt;stack_var2&lt;/code&gt;谁先从栈中分配，不的操作系统，内存管理方式也略有区别。更深一点讲，&lt;code&gt;heap_var&lt;/code&gt;这个指针值也是一个栈变量承载，但&lt;code&gt;heap_var&lt;/code&gt;所指的地址内容才是从堆上分配的内存空间。当退出&lt;code&gt;test&lt;/code&gt;这个函数时，&lt;code&gt;stack_var&lt;/code&gt;与&lt;code&gt;stack_var2&lt;/code&gt;都会先调用&lt;code&gt;Test&lt;/code&gt;的析构，再把其所在的内存空间回收到线程栈中。&lt;/p&gt;

&lt;p&gt;在一些场景下，我们可以利用栈变量当退栈时会自动析构这特性，下面我将举两个应用例子。&lt;/p&gt;

&lt;h2 id=&#34;析构方法释放内存&#34;&gt;析构方法释放内存&lt;/h2&gt;

&lt;p&gt;从堆上面new出来的对象，在一个方法条件分支比较多的情况下，很容易在某个分支少写delete，就会造成内存的泄漏。于是我们可写一个这样的类，在它的析构方法中调用delete回收内存。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;template &amp;lt;typename T&amp;gt;  
class ScopePtr  
{  
public:  
    ScopePtr(T *&amp;amp; pT) : m_pT(pT)  
    {  
    }  

    ~ScopePtr()  
    {  
        if ( NULL != m_pT )  
        {  
            delete m_pT;  
            m_pT = NULL;  
        }  
    }  
private:  
    typedef ScopePtr&amp;lt;T&amp;gt; TScopePtr;  

    ScopePtr(const TScopePtr &amp;amp;) {}  
    TScopePtr&amp;amp; operator = (const TScopePtr &amp;amp;) {}  

    T *&amp;amp; m_pT;  
};

// 使用方式如下：
void test_scope()  
{  
   Test* p = new Test;  
   ScopePtr&amp;lt;Test&amp;gt; tempScopePtr(p);  
}    
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;析构方法打印日志&#34;&gt;析构方法打印日志&lt;/h2&gt;

&lt;p&gt;做软件，写debug日志是一个好的习惯，出问题时可以方便定位问题的发生源。下面的例子是实现是能记录函数在哪一行进入，在哪一行退出。如果函数某个地方抛异常了，则可以根据进入行与退出行相同一看便知。没有抛异常，也很方便查出是在哪个分支退出的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define LOG(fmt, ...) printf(fmt, __VA_ARGS__)  
#define __FUNC_TRACE__  

class FuncTracer  
{  
public:  
    FuncTracer(const char* func, const char* file, const int line) :  
        m_func(func), m_file(file), m_line(line)  
    {  
        LOG(&amp;quot;Enter [%s][%d][%s]./n&amp;quot;, m_file, m_line, m_func);  
    }  

    ~FuncTracer()  
    {  
        LOG(&amp;quot;Exit [%s][%d][%s]./n&amp;quot;, m_file, m_line, m_func);  
    }  

    inline void updateLine(const int line)  
    {  
        m_line = line;  
    }  

private:  
    const char* m_func;  
    const char* m_file;  
    int m_line;  
};  

#ifdef __FUNC_TRACE__  
 #define FUNC_TRACER()  FuncTracer __oFuncTracer(__FUNCTION__, __FILE__, __LINE__)  
 #define FUNC_RET(retVal)  do { __oFuncTracer.updateLine(__LINE__); return retVal; } while(0)  
 #define FUNC_RET_VOID()   do { __oFuncTracer.updateLine(__LINE__); return; } while(0)  
#else  
 #define FUNC_TRACER()  
 #define FUNC_RET(retVal) return retVal;  
 #define FUNC_RET_VOID()  return;  
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述的&lt;code&gt;__FUNCTION__&lt;/code&gt;，&lt;code&gt;__FILE__&lt;/code&gt;与&lt;code&gt;__LINE__&lt;/code&gt;是编译期间的宏，是一个字符串常量，分别表示函数名，文件名与当前行数。但&lt;code&gt;__FUNCTION__&lt;/code&gt;并非标准中定义的，各个编译器命名不同，更通用的宏可以使用&lt;code&gt;boost&lt;/code&gt;中&lt;code&gt;BOOST_CURRENT_FUNCTION&lt;/code&gt;。其中的&lt;code&gt;__FUNC_TRACE__&lt;/code&gt;宏开关表示是否编译时开启函数跟踪。使用方式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int test_trace()  
{  
  FUNC_TRACER();  
  if(...)  
  {   
     switch(...)  
     case  1:  
        FUNC_RET(1);  
     defualt:  
       FUNC_RET(0);  
     ....  
  }  
  FUNC_RET(1);  
}  
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>C&#43;&#43;技巧之operator操作符</title>
      <link>http://lanlingzi.cn/post/technical/csdn/cpp_operator/</link>
      <pubDate>Wed, 24 Jun 2009 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/csdn/cpp_operator/</guid>
      <description>

&lt;p&gt;这篇博文是以前很久写的，贴在我的早期一个blog中，今天google一下，发现还真有不少人转载，可惜并不注明出处。那时觉得&lt;code&gt;operator&lt;/code&gt;比较好玩。C++有时它的确是个耐玩的东东。&lt;code&gt;operator&lt;/code&gt;它有两种用法，一种是&lt;code&gt;operator overloading&lt;/code&gt;（操作符重载），一种是&lt;code&gt;operator casting&lt;/code&gt;（操作隐式转换）。&lt;/p&gt;

&lt;h2 id=&#34;operator-overloading&#34;&gt;operator overloading&lt;/h2&gt;

&lt;p&gt;C++可以通过operator 重载操作符，格式如下：类型&lt;code&gt;T operator 操作符 ()&lt;/code&gt;，如比重载&lt;code&gt;+&lt;/code&gt;，如下所示&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;template&amp;lt;typename T&amp;gt; class A  
{  
public:  
    const T operator + (const T&amp;amp; rhs)  
    {  
     return this-&amp;gt;m_ + rhs;  
    }  
private:  
    T m_;  
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;又比如STL中的函数对象，重载&lt;code&gt;()&lt;/code&gt;，这是C++中较推荐的写法，功能与函数指针类似，如下所示&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;template&amp;lt;typename T&amp;gt; struct A  
{  
   T operator()(const T&amp;amp; lhs, const T&amp;amp; rhs){ return lhs-rhs;}  
};  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;operator-casting&#34;&gt;operator casting&lt;/h2&gt;

&lt;p&gt;C++可以通过operator 重载隐式转换，格式如下： &lt;code&gt;operator&lt;/code&gt; 类型&lt;code&gt;T ()&lt;/code&gt;，如下所示&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class A  
{  
public:  
   operator B* () { return this-&amp;gt;b_;}   
   operator const B* () const {return this-&amp;gt;b_;}      
   operator B&amp;amp; () { return *this-&amp;gt;b_;}  
   operator const B&amp;amp; () const {return *this-&amp;gt;b_;}   

private:  
   B* b_;  
};  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;A a;&lt;/code&gt;当&lt;code&gt;if(a)&lt;/code&gt;，编译时转换成&lt;code&gt;if(a.operator B*())&lt;/code&gt;，其实也就是判断&lt;code&gt;if(a.b_)&lt;/code&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[c&#43;&#43;]自己实现的queue</title>
      <link>http://lanlingzi.cn/post/technical/csdn/cpp_self_impl_queue/</link>
      <pubDate>Sat, 20 Jun 2009 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/csdn/cpp_self_impl_queue/</guid>
      <description>

&lt;p&gt;周末在家，自己用C++练一下手，用顺序存储与链表存储实现了队列queue。queue是一种先进先出的结构，有很多的应用，比如消息队列。&lt;/p&gt;

&lt;h2 id=&#34;顺序存储实现&#34;&gt;顺序存储实现：&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;template&amp;lt;typename T, size_t SIZE&amp;gt;  
class Queue  
{  
public:  
    Queue() :  m_front(0), m_rear(0)  
    {  
    }  
    ~Queue()  
    {  
    }  
    void clear()  
    {  
        m_front = 0;  
        m_rear = 0;  
    }  
    const bool empty() const  
    {  
        return m_front == m_rear;  
    }  
    const int size() const  
    {  
        int s = (m_rear - m_front + (int)SIZE) % (int)SIZE ;  
        return s;  
    }  
    bool push(const T&amp;amp; t)  
    {  
        int pos = (m_rear + 1) % (int)SIZE;  
        //printf(&amp;quot;/n m_rear = %d&amp;quot;, pos);  
        if (pos == m_front)  
        {  
            return false;// it&#39;s full  
        }  
        m_rear = pos;  
        m_data[m_rear] = t;  
        return true;  
    }  
    T&amp;amp; pop()  
    {  
        if (empty())  
        {  
            throw Error&amp;lt;T&amp;gt;(&amp;quot;Overflow&amp;quot;);  
        }  
        m_front = (m_front + 1) % (int)SIZE;  
        //printf(&amp;quot;/n m_front = %d&amp;quot;, m_front);  
        return m_data[m_front];  
    }  
    T&amp;amp; getfront()  
    {  
        return m_data[m_front];  
    }  
    // 遍历所有的节点  
    void traverse( void (*func)(T&amp;amp;) )  
    {  
        if ( empty() ) { return;}  
        for (int idx = m_front + 1; idx != m_rear + 1; idx++)  
        {  
            if ( idx == (int)SIZE)  
            {  
                idx %= (int)SIZE;  
            }  
            //printf(&amp;quot;/n idx = %d&amp;quot;, idx);  
            func(m_data[idx]);  
        }  
    }  
private:  
    T m_data[SIZE];  
    int m_front;  
    int m_rear;  
};  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;链表存储实现&#34;&gt;链表存储实现：&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;template&amp;lt;typename T&amp;gt;  
struct QNode  
{  
    QNode() : m_pNext(NULL)  
    {  
    }  
    T m_data;  
    QNode* m_pNext;  
};  
template&amp;lt;typename T&amp;gt;  
class LQueue  
{  
    typedef QNode&amp;lt;T&amp;gt; TQNode;  
public:  
    LQueue()  
    {  
        TQNode* pTemp = NULL;  
        NEW(pTemp, TQNode() );  
        m_pFront = m_pRear = pTemp;  
        m_size = 0;  
    }  
    ~LQueue()  
    {  
        clear();  
        DELETE(m_pFront);  
    }  
    void clear()  
    {  
        TQNode* pTemp = m_pFront-&amp;gt;m_pNext;  
        while(NULL != pTemp )  
        {  
            TQNode* pTemp2 = pTemp-&amp;gt;m_pNext;  
            DELETE(pTemp);  
            pTemp = pTemp2;  
        }  
        m_pFront-&amp;gt;m_pNext = NULL;  
        m_size = 0;  
    }  
    const bool empty() const  
    {  
        return m_pFront == m_pRear;  
    }  
    const int size() const { return m_size;}  
    bool push(const T&amp;amp; t)  
    {  
        TQNode* pTemp = NULL;  
        NEW(pTemp, TQNode() );  
        if ( NULL == pTemp) { return false;}  
        pTemp-&amp;gt;m_data = t;  
        pTemp-&amp;gt;m_pNext = m_pRear-&amp;gt;m_pNext;  
        m_pRear-&amp;gt;m_pNext = pTemp;  
        m_pRear = pTemp;  
        m_size++;  
        return true;  
    }  
    T pop()  
    {  
        if (empty())  
        {  
            throw Error&amp;lt;T&amp;gt;(&amp;quot;Overflow&amp;quot;);  
        }  
        TQNode* pTemp = m_pFront-&amp;gt;m_pNext;  
        T t = pTemp-&amp;gt;m_data;  
        m_pFront-&amp;gt;m_pNext = pTemp-&amp;gt;m_pNext;  
        if (NULL == m_pFront-&amp;gt;m_pNext)  
        {  
            m_pRear = m_pFront;  
        }  
        DELETE(pTemp);  
        m_size--;  
        return t;  
    }  
    T&amp;amp; getfront()  
    {  
        if (empty())  
        {  
            throw Error&amp;lt;T&amp;gt;(&amp;quot;Overflow&amp;quot;);  
        }  
        TQNode* pTemp = m_pFront-&amp;gt;m_pNext;  
        T t = pTemp-&amp;gt;m_data;  
        return t;  
    }  
    // 遍历所有的节点  
    void traverse( void (*func)(T&amp;amp;) )  
    {  
        if ( empty() ) { return;}  
        TQNode* pTemp = m_pFront-&amp;gt;m_pNext;  
        while(NULL != pTemp)  
        {  
            func(pTemp-&amp;gt;m_data);  
            pTemp = pTemp-&amp;gt;m_pNext;  
        }  
    }  
private:  
    TQNode* m_pFront;  
    TQNode* m_pRear;  
    int m_size;  
};  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;测试代码&#34;&gt;测试代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;void print_queue(int&amp;amp; a)  
{  
    printf(&amp;quot;%d/t&amp;quot;, a);  
}  
void test_queue()  
{  
    LQueue&amp;lt;int&amp;gt; queue;  
    //Queue&amp;lt;int, 4&amp;gt; queue;  
    queue.push(1);  
    queue.push(2);  
    queue.push(3);  
    queue.pop();  
    queue.pop();  
    queue.pop();  
    queue.push(1);  
    queue.push(2);  
    queue.push(3);  
    printf(&amp;quot;/n1 : size: %d /n&amp;quot;, queue.size() );  
    queue.traverse(print_queue);  
    queue.pop();  
    printf(&amp;quot;/n2 : size: %d /n&amp;quot;, queue.size() );  
    queue.traverse(print_queue);  
    queue.push(4);  
    printf(&amp;quot;/n3 : size: %d /n&amp;quot;, queue.size() );  
    queue.traverse(print_queue);  
    queue.clear();  
    printf(&amp;quot;/n4 : size: %d /n&amp;quot;, queue.size() );  
    queue.traverse(print_queue);  
}  
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>C&#43;&#43;技巧之断言Assert</title>
      <link>http://lanlingzi.cn/post/technical/csdn/cpp_static_assert/</link>
      <pubDate>Sun, 14 Jun 2009 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/csdn/cpp_static_assert/</guid>
      <description>

&lt;p&gt;断言的应该是一种编程的常见技巧。我所应用的断言有两种，一种是动态断言，即大家所熟知的C标准库的assert()宏，一种是C++中的静态断言，即在编译期间检查。&lt;/p&gt;

&lt;h2 id=&#34;动态断言&#34;&gt;动态断言：&lt;/h2&gt;

&lt;p&gt;assert宏的原型定义在&lt;assert.h&gt;中，其作用是如果它的条件返回错误，则终止程序执行，原型定义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;assert.h&amp;gt;  
void assert( int expression );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;assert&lt;/code&gt;的作用是先计算表达式&lt;code&gt;expression&lt;/code&gt; ，如果其值为假（即为0），那么它先向&lt;code&gt;stderr&lt;/code&gt;打印一条出错信息，然后通过调用&lt;code&gt;abort&lt;/code&gt; 来终止程序运行。&lt;/p&gt;

&lt;p&gt;大家要注意是，其中的表达式为假时，会终止程序运行，包括我在内经常会写错代码，断言一个指针是否为空，往往写成了
&lt;code&gt;assert(!p);&lt;/code&gt;其实应该写成&lt;code&gt;assert(p);&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;assert&lt;/code&gt;是运行期的判断，并且会强制终止程序，一般要求只能用于&lt;code&gt;debug&lt;/code&gt;版本中，是为了尽可能快的发现问题。尤其在我所从事的电信软件产品中，&lt;code&gt;assert&lt;/code&gt;是要从&lt;code&gt;release&lt;/code&gt;版本中去掉。所以一般开发会重新定义&lt;code&gt;assert&lt;/code&gt;宏。&lt;/p&gt;

&lt;h2 id=&#34;静态断言&#34;&gt;静态断言：&lt;/h2&gt;

&lt;p&gt;在新的&lt;code&gt;C++&lt;/code&gt;标准中&lt;code&gt;C++0x&lt;/code&gt;中，加了对静态断言的支持，引入了新的关键字&lt;code&gt;static_assert&lt;/code&gt;来表示静态断言。&lt;/p&gt;

&lt;p&gt;使用静态断言，我们可以在程序的编译时期检测一些条件是否成立。但这个关键字太新了，没有几个编译器是支持的(好像VC2008支持，我用VC很少，主要是在linux下C++编程)。&lt;/p&gt;

&lt;p&gt;于是可以使用C++现有的模板特性来实现静态断言的功能。&lt;code&gt;boost&lt;/code&gt;中也已有&lt;code&gt;BOOST_STATIC_ASSERT&lt;/code&gt;宏的实现，有兴趣的同学可以down下来仔细研究一下，它的断言信息更丰富，下面为我的简单实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// declare a tempalte class StaticAssert.  
template &amp;lt;bool assertion&amp;gt; struct StaticAssert;  

// only partial specializate parameter&#39;s value is true.  
template &amp;lt;&amp;gt; struct StaticAssert&amp;lt;true&amp;gt;   
{  
  enum { VALUE = 1 };  
};

#define STATIC_ASSERT(expression) (void)StaticAssert&amp;lt;expression&amp;gt;::VALUE  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原理是，先声明一个模板类，但后面仅仅偏特化参数值为true的类，而为false的类则一个未定义的类，即是一个未完整的类型,编译期间无法找到&lt;code&gt;StaticAssert&amp;lt;false&amp;gt;::VALUE&lt;/code&gt;类型。举例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;STATIC_ASSERT(4 == sizeof(long) ); //在 32bit机上OK  
STATIC_ASSERT(4 == sizeof(long) ); //在 64bit机上NG，long为8字节
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;静态断言在编译时进行处理，不会产生任何运行时刻空间和时间上的开销，这就使得它比assert宏具有更好的效率。另外比较重要的一个特性是如果断言失败，它会产生有意义且充分的诊断信息，帮助程序员快速解决问题。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>C&#43;&#43;技巧之宏Macro应用</title>
      <link>http://lanlingzi.cn/post/technical/csdn/cpp_macro_rule/</link>
      <pubDate>Fri, 12 Jun 2009 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/csdn/cpp_macro_rule/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;宏不要用来定义常量，因为宏变量是没有类型安全，也没有名字空间约束，会造成名字的污染。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;宏的展开是一行，所以宏中的注释不能使用&lt;code&gt;//&lt;/code&gt;，只能使用&lt;code&gt;/* */&lt;/code&gt;。宏的代码也不能gdb跟踪，宏中代码逻辑要尽量简单。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;宏的参数一般情况下使用时要用()括起来，如:
&lt;code&gt;#define MAX(a, b) a /2 &amp;gt; b ? a /2  : b&lt;/code&gt;
MAX(3,4)使用没有问题，但MAX(3+4, 4)却有问题，因为宏的参数仅为符号替换。
应用定义为&lt;code&gt;#define MAX(a, b)  (a) / 2 &amp;gt;  (b) ?  (a) /2 : (b)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;宏的连接符分为&lt;code&gt;#&lt;/code&gt;与&lt;code&gt;##&lt;/code&gt;
&lt;code&gt;#&lt;/code&gt;表示一个符号直接转换为字符串，如
&lt;code&gt;#define CAT(x) &amp;quot;First &amp;quot;#x &amp;quot; Third&amp;quot;
const char * pszStr = CAT(Second);&lt;/code&gt; str的内容就是&amp;rdquo;First Second Third&amp;rdquo;，也就是说#会把其后的符号直接加上双引号。
&lt;code&gt;##&lt;/code&gt;符号会连接两个符号，从而产生新的符号(词法层次)，例如：
&lt;code&gt;#define NAME( x ) name_##x&lt;/code&gt;
&lt;code&gt;char* NAME( szlanny );&lt;/code&gt; 宏被展开后将成为：&lt;code&gt;char* name_szlanny;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;宏中如有存在if等语句产生的分支，要使用do{}while(0)包起来，如
&lt;code&gt;#define TEST(a ) if ( 0 == a ) dosomething()&lt;/code&gt;
如果在下面使用是会存在问题&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if ( 1 == b)
TEST(a ):
else
{
 dootherthing();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那当代码展开之后，宏中的if与外面的else是一起匹配，而不是else与if ( 1 == b)匹配。
所以上述宏要修改为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define TEST(a )  do {/
if ( 0 == a )  { dosomething(); }  }while(0)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于可变参宏，可以使用&lt;strong&gt;VA_ARGS&lt;/strong&gt;，GCC支持它，但并非所有的编译器支持，如果你的代码要跨平台，慎用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define LOG( format, ... ) printf( format, __VA_ARGS__ )
LOG( &amp;quot;%s %d&amp;quot;, str, count );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;__VA_ARGS__&lt;/code&gt;被自动替换为参数列表。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;宏不能嵌套使用，如:
&lt;code&gt;#define TEST( x ) ( x + TEST( x ) )&lt;/code&gt;，编译器展开过程中发现第二个TEST，那么就将这个TEST当作一般的符号。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当宏的逻辑比较多时，可以考虑宏中使用模板方法来代替宏的逻辑实现。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>[c&#43;&#43;]自己实现的stack</title>
      <link>http://lanlingzi.cn/post/technical/csdn/cpp_self_impl_stack/</link>
      <pubDate>Thu, 11 Jun 2009 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/csdn/cpp_self_impl_stack/</guid>
      <description>&lt;p&gt;还是前一段时间需要任职资格考试，自己练习一下栈stack的简易实现，今天把它贴出来，暴露的接口与STL类似，没有实现iterator迭代器。实现有两种方式， 基于顺序存储与链式存储。栈的特点是“后进先出”，在数学表达式运算，编译语法分析中，程序函数调用时最为常见。&lt;/p&gt;

&lt;p&gt;公用的宏与异常类:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define NEW(var, T) do { /  
   try {                 /  
       var = new T;      /  
   }catch(...) {         /  
       var = NULL;       /  
   }                     /  
}while(0)  

#define DELETE(var) do { /  
    if(NULL != var)      /  
    {                    /  
       delete var;       /  
       var = NULL;       /  
    }                    /  
}while(0)  

template&amp;lt;typename T&amp;gt;  
struct Error  
{  
   Error(const char* pszInfo = &amp;quot;Overflow&amp;quot;)  
   {  
     printf(&amp;quot;/nThrow a error, Info :%s/n&amp;quot;, pszInfo);  
   }  
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;顺序存储，模板实现，其中参数T为栈的存储类型，参数SIZE表示最大存储的个数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;template&amp;lt;typename T, size_t SIZE&amp;gt;  
class Stack  
{  
public:  
    Stack() :  
        m_size(0)  
    {  
    }  
    ~Stack()  
    {  
    }  

    bool push(const T&amp;amp; t)  
    {  
        if (m_size == SIZE)  
        {  
            return false;  
        }  

        m_data[m_size] = t;  
        m_size++;  
        return true;  
    }  

    T&amp;amp; pop()  
    {  
        if (0 == m_size)  
        {  
            throw Error&amp;lt;T&amp;gt; (&amp;quot;Overflow&amp;quot;);  
        }  
        else  
        {  
            T&amp;amp; t = m_data[m_size];  
            m_size--;  
            return t;  
        }  
    }  

    void clear()  
    {  
        m_size = 0;  
    }  

    const bool empty() const  
    {  
        return 0 == m_size;  
    }  

    const size_t size() const  
    {  
        return m_size;  
    }  

    // 遍历所有的节点  
    void traverse(void(*func)(T&amp;amp;))  
    {  
        if (empty())  
        {  
            return;  
        }  

        for (size_t idx = 0; idx &amp;lt; m_size; ++idx)  
        {  
            func(m_data[idx]);  
        }  
    }  

private:  
    T m_data[SIZE];  
    size_t m_size;  
};  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;链式存储，也是模板实现，内部结构为一单向链表。入栈的元素加到链表的表头。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;template&amp;lt;typename T&amp;gt;  
struct SNode  
{  
    T m_data;  
    SNode* m_pNext;  

    SNode() :  
        m_pNext(NULL)  
    {  
    }  
};  

template&amp;lt;typename T&amp;gt;  
class LStack  
{  
    typedef SNode&amp;lt;T&amp;gt; TNode;  
public:  
    LStack() :  
        m_size(0)  
    {  
        NEW(m_pTop, TNode());  
        if (NULL != m_pTop)  
        {  
            m_pTop-&amp;gt;m_pNext = NULL;  
        }  
    }  

    ~LStack()  
    {  
        clear();  
        DELETE(m_pTop);  
    }  

    void clear()  
    {  
        if (NULL == m_pTop)  
        {  
            return;  
        }  

        TNode* pTemp = m_pTop-&amp;gt;m_pNext;  
        while (NULL != pTemp)  
        {  
            TNode* pTemp2 = pTemp-&amp;gt;m_pNext;  
            DELETE(pTemp);  
            pTemp = pTemp2;  
        }  
        m_pTop-&amp;gt;m_pNext = NULL;  
        m_size = 0;  
    }  

    const bool empty() const  
    {  
        return (NULL == m_pTop || NULL == m_pTop-&amp;gt;m_pNext) ? true : false;  
    }  

    const size_t size() const  
    {  
        return m_size;  
    }  

    bool push(const T&amp;amp; t)  
    {  
        if (NULL == m_pTop)  
        {  
            return false;  
        }  

        TNode* pTemp = NULL;  
        NEW(pTemp, TNode());  
        if (NULL == pTemp)  
        {  
            return false;  
        }  
        pTemp-&amp;gt;m_data = t;  
        pTemp-&amp;gt;m_pNext = m_pTop-&amp;gt;m_pNext;  
        m_pTop-&amp;gt;m_pNext = pTemp;  

        m_size++;  

        return true;  
    }  

    T pop()  
    {  
        TNode* pTemp = m_pTop-&amp;gt;m_pNext;  
        if (NULL == pTemp)  
        {  
            throw Error&amp;lt;T&amp;gt; (&amp;quot;Overflow&amp;quot;);  
        }  

        T t = pTemp-&amp;gt;m_data;  
        m_pTop-&amp;gt;m_pNext = pTemp-&amp;gt;m_pNext;  
        DELETE(pTemp);  
        m_size--;  
        return t;  
    }  

    // 遍历所有的节点  
    void traverse(void(*func)(T&amp;amp;))  
    {  
        if (empty())  
        {  
            return;  
        }  
        TNode* pTemp = m_pTop-&amp;gt;m_pNext;  
        while (NULL != pTemp)  
        {  
            func(pTemp-&amp;gt;m_data);  
            pTemp = pTemp-&amp;gt;m_pNext;  
        }  
    }  

private:  
    TNode* m_pTop;  
    size_t m_size;  
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void print_stack(int&amp;amp; a)  
{  
    printf(&amp;quot;%d/t&amp;quot;, a);  
}  

void test_stack()  
{  
    printf(&amp;quot;stack test /n&amp;quot;);  
    //Stack&amp;lt;int, 4&amp;gt; stack;  
    LStack&amp;lt;int&amp;gt; stack;  

    stack.push(1);  
    stack.push(2);  
    stack.push(3);  
    stack.pop();  
    stack.pop();  
    stack.pop();  
    stack.push(1);  
    stack.push(2);  
    stack.push(3);  

    printf(&amp;quot;/n1 : size: %d /n&amp;quot;, stack.size());  
    stack.traverse(print_stack);  

    stack.pop();  
    printf(&amp;quot;/n2 : size: %d /n&amp;quot;, stack.size());  
    stack.traverse(print_stack);  

    stack.push(4);  
    printf(&amp;quot;/n3 : size: %d /n&amp;quot;, stack.size());  
    stack.traverse(print_stack);  

    stack.pop();  
    printf(&amp;quot;/n4 : size: %d /n&amp;quot;, stack.size());  
    stack.traverse(print_stack);  

    stack.clear();  
    printf(&amp;quot;/n5 : size: %d /n&amp;quot;, stack.size());  
    stack.traverse(print_stack);  
}  
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>用C&#43;&#43;模板来展示new与delete操作符原理</title>
      <link>http://lanlingzi.cn/post/technical/csdn/cpp_new_delete/</link>
      <pubDate>Mon, 08 Jun 2009 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/csdn/cpp_new_delete/</guid>
      <description>&lt;p&gt;C++中的new与delete可以认为是C中的malloc与free的升级版本。new包含两部分:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一部分是与malloc功能相同，是从堆上面申请内存块&lt;/li&gt;
&lt;li&gt;第二部是调用类的构造方法来初始化刚申请的内存。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;delete是new的逆过程，先调用类的析构方法来反初始化，再把刚申请的内存还给堆。&lt;/p&gt;

&lt;p&gt;new []与delete []是针对数组操作符，要注意是通过new []分配的对象，不能用delete来释放对象，否则会有内存泄漏。当然通过new分配的对象，不能用delete[]来释放对象。后面我会通过代码来说明为什么。&lt;/p&gt;

&lt;p&gt;下面是C++ 中的new与delete函数原型，申请内存失败会抛出异常bad_alloc&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void* operator new(std::size_t) throw (std::bad_alloc);
void* operator new[](std::size_t) throw (std::bad_alloc);
void operator delete(void*) throw();
void operator delete[](void*) throw();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用举例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int* p1 = new int();
delete p2;

int* p2 = new int[5];
delete [] p2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;终于到了用模板来模拟new与delete操作符，代码中有注释说明，其中对于调用类的构造方法，采用一种C++标准中称作in-place construtor的方式。使用原型为T* = new(pbuff) T()，直译的话就是在pbuff这块内存构造T类，而不用再去堆上面申请内存。这种技巧大量应用在对象池的实现中，即pbuff这块内存可以挂在链表中反复地使用（这里先不展开说了）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * A simulation of c++ new T() &amp;amp; new T(param) operation
 */  
struct NewObj
{
    template &amp;lt;typename T&amp;gt;
    inline void operator()(T*&amp;amp; pObj)
    {
        // allocate memory form heap
        void * pBuff = malloc(sizeof(T));
        // call constructor
        pObj = new (pBuff) T();
    }

    template &amp;lt;typename T, typename P&amp;gt;
    inline void operator()(T*&amp;amp; pObj, const P&amp;amp; param)
    {
        // allocate memory form heap
        void * pBuff = malloc(sizeof(T));
        // call constructor, pass one param
        pObj = new(pBuff) T(param);
    }
};  

/**
 * A simulation of c++ delete T operation
 */  
struct DeleteObj  
{  
    template &amp;lt;typename T&amp;gt;  
    inline void operator()(T*&amp;amp; pObj)  
    {  
        if ( NULL == pObj ) { return ;}  
        // call destructor  
        pObj-&amp;gt;~T();  
        // free memory to heap  
        free((void*)pObj);  
        pObj = NULL;  
    }  
};  

/**
 * A simulation of c++ new T[N]() operation
 */  
struct NewObjArray  
{  
    template &amp;lt;typename T&amp;gt;  
    inline void operator()(T*&amp;amp; pObj, unsigned int size)  
    {  
        // save the number of array elements in the beginning of the space.  
        long * pBuff = (long *) malloc (sizeof(T) * size + sizeof(long));  
        *((unsigned int *) pBuff) = size;  
        pBuff++;  

        // change pointer to T type, then can use pT++  
        T * pT = (T *) pBuff;  
        // save the pointer to the start of the array.  
        pObj = pT;  
        // now iterate and construct every object in place.  
        for (unsigned int i = 0; i &amp;lt; size; i++)  
        {  
            new((void *) pT) T();  
            pT++;  
        }  
    }  
};  


/**
 * A simulation of c++ delete [] T operation
 */  
struct DeleteObjArray  
{  
    template &amp;lt;typename T&amp;gt;  
    inline void operator()(T*&amp;amp; pObj)  
    {  
        unsigned int size = *((unsigned int *) ((long *) pObj - 1));  

        T * pT = pObj;  
        // call destructor on every element in the array.  
        for (unsigned int i = 0; i &amp;lt; size; i++)  
        {  
            pT-&amp;gt;~T();  
            pT++;  
        }  
        // free memory to heap.  
        free ((void *) ((long *) pObj - 1));  
        pObj = NULL;  
    }  
};  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct TestClass  
{  
    TestClass() : mem1(0), mem2(0)  {}  

    TestClass(int m) : mem1(m), mem2(0) {}  

    int mem1;  
    long mem2;  
};  

void test_new_delete()  
{  
    TestClass* p1 = NULL;  
    NewObj()(p1);  
    printf(&amp;quot;%p/n&amp;quot;, p1);  
    DeleteObj()(p1);  

    //  
    TestClass* p2 = NULL;  
    NewObj()(p2, 0);  
    printf(&amp;quot;%p/n&amp;quot;, p2);  
    DeleteObj()(p2);  

    //  
    TestClass* p3 = NULL;  
    NewObjArray()(p3, 5);  
    printf(&amp;quot;%p/n&amp;quot;, p3);  
    DeleteObjArray()(p3);  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;测试环境为eclipse+cdt+ubuntu+gcc，注意头文件需要&lt;code&gt;#include&amp;lt;new&amp;gt;&lt;/code&gt;，使用&lt;code&gt;#include&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;会导致编译不过，因为&lt;code&gt;in-place construtor&lt;/code&gt;是C++中的新玩意。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>[c&#43;&#43;]常见的几个排序算法</title>
      <link>http://lanlingzi.cn/post/technical/csdn/cpp_aglos/</link>
      <pubDate>Sun, 07 Jun 2009 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/csdn/cpp_aglos/</guid>
      <description>

&lt;p&gt;前一段时间需要任职资格考试，于是又拿起丢了几年的数据结构书看了看，温习了一下常见的几个排序算法。今天特把我写的学习代码贴了出来。排序的算法常见有插入排序，选择排序与交换排序，较复杂一点还有归并排序与基数排序，概念性的东西我就不多说了，大家可以找一本严老师数据结构书看看。读大学时不觉得怎么样，现在再来看看，又结合这几年的编程经验，通过C++风格函数子造了一遍轮子。&lt;/p&gt;

&lt;h2 id=&#34;排序算法&#34;&gt;排序算法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;先来一个排序中的比较函数子，实现是左值小于右值。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt; template&amp;lt;typename T&amp;gt;
struct CmpFuctor
{
  bool operator()(const T&amp;amp; lhs, const T&amp;amp; rhs)
  {
    return lhs &amp;lt; rhs;
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;交换排序中用到的交换两个元素的函数。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;template&amp;lt;typename T&amp;gt;
void swap(T* lhs, T* rhs)
{
  T tmp = *lhs;
  *lhs = *rhs;
  *rhs = tmp;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;排序前后，我们自然要观察前后元素的顺序，那也少了下面这个函数。即遍历整个数组，再回调函数指针func，把元素通过引用传递出来。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;template&amp;lt;typename T&amp;gt;
void traverse(T* pArray, const int size, void (*func)(T&amp;amp;) )
{
  for(int idx =0; idx&amp;lt; size; idx++)
  {
    func(pArray[idx]);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;我们先来看一个最简单的插入排序。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;template&amp;lt;typename T, typename CMP &amp;gt;
void insertsort(T* pArray, const int size, CMP cmp)
{
  for(int idx =0; idx&amp;lt; size; idx++)
  {
    T temp = pArray[idx];
    int pos = idx -1;
    while( pos &amp;gt;= 0 &amp;amp;&amp;amp; cmp(temp, pArray[pos]) ) // &amp;lt;
    {
      pArray[pos+1] = pArray[pos];
      pos--;
    }
    pArray[pos+1] = temp;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;再对上面的插入排序改进，查找为折半插入排序。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;template&amp;lt;typename T, typename CMP&amp;gt;
void binaryinsertsort(T* pArray, const int size, CMP cmp)
{
  for(int idx = 1; idx &amp;lt; size; idx++)
  {
    int left = 0;
    int right = idx -1;
    T temp = pArray[idx];
    while( left &amp;lt;= right)
    {
      int middle = (left + right) / 2;

      if ( cmp(temp, pArray[middle] )) // &amp;lt;
      {
        right = middle - 1;
      }
      else
      {
        left = middle + 1;
      }
    }

    int j = idx-1;
    for(; j &amp;gt;= right+1; j--)
    {
      pArray[j+1] = pArray[j];
    }
    pArray[right+1] = temp;

  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;再来一个改进版的插入排序。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;是希尔排序。希尔排序的基本思想是：先将整个待排记录序列分割成若干小组（子序列），分别在组内进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;template&amp;lt;typename T, typename CMP&amp;gt;
void shellsort(T* pArray, const int size, CMP cmp)
{
  int j = 0;
  int d = size / 2;

  // 通过增量控制排序的执行过程
  while( d &amp;gt; 0 )
  {
    for(int i = d; i&amp;lt; size;i++)
    {
      j = i - d;
      while(j &amp;gt;= 0)
      {
        // 对各个分组进行处理
        if ( cmp(pArray[j+d], pArray[j]) )
        {
          swap(&amp;amp;pArray[j], &amp;amp;pArray[j+d]);
          j -= d;
        }
        else
        {
          j = -1;
        }
      }
    }
    d /= 2; //递减增量d
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;下面是一种简单选择排序算法。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;template&amp;lt;typename T, typename CMP&amp;gt;
void selectsort(T* pArray, const int size, CMP cmp)
{
  for(int idx = 0; idx &amp;lt; size; idx++)
  {
    for(int pos = idx + 1; pos &amp;lt; size; pos++)
    {
      if( cmp(pArray[pos], pArray[idx]) ) // &amp;lt;
      {
        swap(&amp;amp;pArray[pos], &amp;amp;pArray[idx]);
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;交换排序中最简单的冒泡排序。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt; template&amp;lt;typename T, typename CMP&amp;gt;
void bubblesort(T* pArray, const int size, CMP cmp)
{
  for(int idx =0; idx &amp;lt; size; idx++)
  {
    for(int pos = 0; pos &amp;lt;= size - idx;pos++)
    {
      if( cmp(pArray[pos+1], pArray[pos]) ) // &amp;lt;
      {

        swap(&amp;amp;pArray[pos], &amp;amp;pArray[pos+1]);
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;交换排序中最简单的快速排序。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;template&amp;lt;typename T, typename CMP&amp;gt;
int partition(T* pArray, int p, int r, CMP cmp)
{
  int i = p - 1;
  int j = 0;
  for(j = p; j &amp;lt; r; j++)
  {
    if(cmp(pArray[j], pArray[r])) //pArray[j] &amp;gt;= pArray[r]
    {
      i++;
      swap(&amp;amp;pArray[i], &amp;amp;pArray[j]);
    }
  }
  swap(&amp;amp;pArray[i + 1], &amp;amp;pArray[r]);
  return i + 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;测试代码&#34;&gt;测试代码&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;void print(int&amp;amp; a)
{
  printf(&amp;quot;%d/t&amp;quot;, a);
}

int genrandom(int min, int max)
{
  return (min + (int)(((float)rand()/RAND_MAX)*(max - min)));
}

void random(int&amp;amp; a )
{
  a = genrandom(-50, 100);
}

void sort_test()
{
  int A[] = {4, 1, 44, -12, 5, 125, 30};
  int len = sizeof(A) / sizeof(int);

  //
  traverse(A, len, print);
  printf(&amp;quot;/n&amp;quot;);
  insertsort(A, len, CmpFuctor&amp;lt;int&amp;gt;() );
  traverse(A, len, print);
  printf(&amp;quot;/n&amp;quot;);

  //
  traverse(A, len, random);
  traverse(A, len, print);
  printf(&amp;quot;/n&amp;quot;);
  binaryinsertsort(A, len, CmpFuctor&amp;lt;int&amp;gt;() );
  traverse(A, len, print);
  printf(&amp;quot;/n&amp;quot;);

  //
  traverse(A, len, random);
  traverse(A, len, print);
  printf(&amp;quot;/n&amp;quot;);
  shellsort(A, len, CmpFuctor&amp;lt;int&amp;gt;() );
  traverse(A, len, print);
  printf(&amp;quot;/n&amp;quot;);


  //
  traverse(A, len, random);
  traverse(A, len, print);
  printf(&amp;quot;/n&amp;quot;);
  bubblesort(A, len, CmpFuctor&amp;lt;int&amp;gt;() );
  traverse(A, len, print);
  printf(&amp;quot;/n&amp;quot;);

  //
  traverse(A, len, random);
  traverse(A, len, print);
  printf(&amp;quot;/n&amp;quot;);
  selectsort(A, len, CmpFuctor&amp;lt;int&amp;gt;() );
  traverse(A, len, print);
  printf(&amp;quot;/n&amp;quot;);

  //
  traverse(A, len, random);
  traverse(A, len, print);
  printf(&amp;quot;/n&amp;quot;);
  quicksort(A, 0, len, CmpFuctor&amp;lt;int&amp;gt;() );
  traverse(A, len, print);
  printf(&amp;quot;/n&amp;quot;);

}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;上面的函数有C风格的函数指针与C++风格函数子（Functor，有时也叫函数对象），函数使用了C++中模板的一些特性，测试环境为eclipse+cdt+gcc。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
  </channel>
</rss>