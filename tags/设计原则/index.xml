<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>设计原则 on 蘭陵N散記</title>
    <link>http://lanlingzi.cn/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/index.xml</link>
    <description>Recent content in 设计原则 on 蘭陵N散記</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <atom:link href="http://lanlingzi.cn/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>软件变革下设计原则</title>
      <link>http://lanlingzi.cn/post/technical/2016/0910_soft_design/</link>
      <pubDate>Sat, 10 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2016/0910_soft_design/</guid>
      <description>&lt;p&gt;传统大型软件系统 ，多以功能需求驱动设计与开发。在体系结构上是一个单体应用，变更修改往往是牵一而发动全身；在系统生态上是一个封闭系统，系统集成是大量定制开发。单体封闭的系统在交付中面临着越来越多的挑战，提升系统的竞争力首先是在软件架构上先行。软件系统发展也需像硬件一样不断地更新换代，软件架构设计需要输入新的思维。只有在思想上彻底地变革，才能摆脱原有的束缚与局限性。&lt;/p&gt;

&lt;h2 id=&#34;体验为王&#34;&gt;体验为王&lt;/h2&gt;

&lt;p&gt;软件原本是一种信息技术发展不断地服务于各行各业，软件在实现上又是偏向技术性。如何让普通用户能够较好地使用软件，而不需要这方面的专业背景，需要思考软件减少数字与体验之间鸿沟。互联网思维一直讲求如何让用户感知到你对他的价值，而且把这个价值争取做到极致，超出用户的预期，这个就叫体验。只有用户产生体验之后，才能形成口碑。简而言之，体验的思想，就是从用户的感受出发，把它做到极致。
&lt;/p&gt;

&lt;p&gt;正如我们所见到的，iPhone的成功原因之一，就是注重用户的体验获得巨大的成功。今天，人们于弹指间操控丰富业务。无数应用，以碎片化的形式填满用户时间，连接起永远在线的数字生活。一个显见的事实是，“体验”正被尊奉为至高无上的法则，用户已重掌驱动行业发展的威权。&lt;/p&gt;

&lt;p&gt;曾经一位领导说我们的软件系统发展应该先是“能用”，再是“好用”，最后是“易用”。这其实也是软件系统从功能为主朝用户至上，体验为王方向发展。套用阿里一句词：“让天下没有难用的软件”。&lt;/p&gt;

&lt;p&gt;那如何能做到“体验为王”的软件设计呢？&lt;/p&gt;

&lt;p&gt;作名一名架构师，首先要始终以用户和角色为中心，要从原有的我能为你提供什么功能，转变成用户最需要什么为出发点。首先要把自己当成用户，如果连自己都不去使用自己设计的系统，又如何把系统设计好呢。&lt;/p&gt;

&lt;p&gt;有人说，软件架构设计不是UI/UE设计，架构设计是功能逻辑设计，是技术实现设计，是物理部署设计；而用户体验只是UI/UE都需要考虑的。UI设计，确切地说，用户使用界面上设计首先要考虑用户体验。但体验不仅仅是界面上的交互操作的易用性，心理感受等。试想，如果你浏览一个网页或使用一个App，虽UI设计非常符合用户的使用习惯，但响应速度却非常地慢。这也不会是好的体验。速度上需要零等待，存储上需要大容量，并发上需要高吞量。这些都需要在软件系统架构上着重设计。&lt;/p&gt;

&lt;p&gt;软件架构设计要以需求的场景化、实例化驱动设计。无法场景化的需求往往是伪需求。真正的需求是满足目标用户在特定场景下的目标。作为架构设计师，要弄清其中两个关键因素：1）目标用户；2）特定场景下的目标。&lt;/p&gt;

&lt;h2 id=&#34;平台为本&#34;&gt;平台为本&lt;/h2&gt;

&lt;p&gt;平台化分为技术支撑型平台和应用实现型平台。技术支撑型平台的用户为软件开发人员，提供者负责平台的维护和升级，用户负责基于平台的上层实现。这类平台包括软件中间件、开发工具、应用服务器等。应用实现型平台的用户为终端用户，提供者不但负责平台的维护和升级，还要负责实现基于平台的上层应用。&lt;/p&gt;

&lt;p&gt;平台化首先需要在架构设计上考虑系统的开放性，通常的做法是系统功能服务化，API化。采用标准的通信协议，让系统易于被集成。系统具备更好的应用开发和维护的工具和接口，实施时可以迅速根据用户的特点进行部署和二次开发，用户可以最大限度地使用贴近自身特点来重新定义软件功能。&lt;/p&gt;

&lt;p&gt;像Saleforce等SaaS平台一样，平台化使运行于上层的应用软件在某种程度上做到与技术无关，而是面向具体业务，提供更为领域化的DSL。平台化提供各种易于组装的套件，可定制修改的业务模板。这样才能面向合作伙伴，构建平台之上的工具链，生态社区等。&lt;/p&gt;

&lt;p&gt;软件系统在研发和使用过程中需求变更不可避免。平台化的软件也在架构设计上，需地支持系统的平滑演进与对外接口兼容。这也需要在设计上考虑平台与上层业务之间的边界划分。上层的业务是最为变更频繁的，一是业务领域特性一般的变更不要侵入到平台。其二、平台的发展也不能影响上层业务的运行。当系统面对市场需要时，要评估这些需求是否需要在平台增加或改动哪些功能，平台软件是要随着客户需求而发展演进的。只有不断切合上层业务发展诉求的平台才具有更久的生命力。&lt;/p&gt;

&lt;h2 id=&#34;内生敏捷&#34;&gt;内生敏捷&lt;/h2&gt;

&lt;p&gt;业务逻辑复杂多变，如何保证程序逻辑的代码稳定是架构师需要解决的问题，良好的模块划分和扩展性强的接口设计都是解决这个问题的利器。微服务化，大系统小做。系统分解的目标并不仅仅是搞出一堆很小的服务，这不是目标；真正的目标是解决系统在业务急剧增长时遇到的问题。&lt;/p&gt;

&lt;p&gt;模块化，微服务化的让某一个功能足够内聚，足够小，代码容易理解、开发效率提高。服务之间可以独立部署，微服务架构让持续集成（CI），持续部署（CD）成为可能，基于数据化地构建软件生产流水线成为可能。各个服务之间可以在流水线上按功特性灵活组装。&lt;/p&gt;

&lt;p&gt;软件的本质是要面对各种业务需求的变化，这需要系统高度地抽象化，以不变来应对万变。使用一切可以减少编码的技术，例如元数据驱动。软件系统设计已经发展到使用运行时引擎从元数据（即关于应用程序本身的数据）生成应用程序组件的阶段。在一个定义良好的元数据驱动的体系结构中，已编译的运行时引擎（内核）、应用数据、描述一个应用程序的基础功能的元数据，以及与每个租户的数据和定制相关的元数据之间有一个明确的分离。这些明显的边界使人们有可能独立更新系统内核，修改的核心应用程序，或定制租户的具体组成部分，虚拟意义上来说，几乎不会影响其他人。&lt;/p&gt;

&lt;h2 id=&#34;数据驱动&#34;&gt;数据驱动&lt;/h2&gt;

&lt;p&gt;数据驱动是系统内生的数据感知，基于系统运行数据进行系统的预测与资源优化。数据驱动的终极目标是希望利用数据能够直接在生产环境带来改变，提供价值。&lt;/p&gt;

&lt;p&gt;数据驱动自动化干预，需要不断优化的分析算法，利用数据基础在特定领域完成基于算法的自动调整。算法线上部署除了对平台和算法本身的支持之外，还需要考虑：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数据的及时性：实时数据和历史数据的组合，在特定周期下替换历史数据。&lt;/li&gt;
&lt;li&gt;异常数据的容忍：线上算法的输入无法做到离线的清洗水平，需要更健壮的数据预处理模块。&lt;/li&gt;
&lt;li&gt;算法的迭代：需要可靠的离线迭代平台来纠正线上算法运行过程中的误差和偏离。采集线上的数据到离线平台，通过离线平台调整参数和适应性。支持从离线平台推送新的算法。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个系统的开放性，也体现在数据的开放性。系统架构上需考虑可被高层的系统，更深度的分析。不同维度与不同层次的分析，才能让数据变得更有价值。&lt;/p&gt;

&lt;h2 id=&#34;原生云化&#34;&gt;原生云化&lt;/h2&gt;

&lt;p&gt;原生云化指“Cloud Native”，它是多种不同思想的一个集合，这些思想帮助软件系统转移到云平台。这些思想包括DevOps、持续交付、微服务、敏捷基础设施、康威定律等。“Cloud Native”没有标准的官方定义，但包括如下几个特征：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可移植：应用层与物理层隔离。应用从开发环境迁移到物理环境无需改变环境配置。&lt;/li&gt;
&lt;li&gt;自动化：通过持续集成和自我修复系统将IT基础设施的开发和部署进行自动化。&lt;/li&gt;
&lt;li&gt;效率提升：通过引入全新方式来降低运维成本，让系统管理员可以有更多时间去改进系统，而不是把时间都用在维护系统上。&lt;/li&gt;
&lt;li&gt;意识改变：DevOps的兴起以及运维和开发人员越来越多的共同协作发布服务，包括微服务和传统服务，让用户意识到服务发布的速度和敏捷性，已经和稳定性一样重要。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;原生云化的系统也是具有&lt;a href=&#34;https://12factor.net/&#34;&gt;12因子&lt;/a&gt;。原生云化首先考虑是的分布式一切。分布式架构可以以水平扩展，通过横向扩充节点，如一个节点扩充到多个节点，每个节点运行独立实例，节点与节点之间通过网络互连，随着节点扩充系统处理能力能够随之提升，单节点失效时，整个集群仍然可以对外提供服务。遵循12因子原则的应用程序，具有一致的架构接口。为了使创建的分布式应用马上就可以部署在云中，这些接口的构建采用一种无状态、面向进程的设计模式。&lt;/p&gt;

&lt;p&gt;多租户也是云计算的基本属性之一，原生云化的系统也必定是多租户架构的系统。利用多租户带来资源上高度共享模式，提高资源资源利用率，降低单位资源成本。但是共享资源越多，会带来租户的隔离性难度越大，成本越高。在按隔离程序不同层次，可分为物理多租架构与逻辑多租架构，物理多租架构技术如采用虚拟化技术，Docker容器，以及应用容器技术来隔离租户资源。逻辑多租架构技术如应用程序进程间隔离，数据切割隔离。&lt;/p&gt;

&lt;p&gt;原生云化的系统也是最大程度自动化。健壮自动化几乎能处理传统IT中需要手工处理的所有事情：当应用实例增减时更新路由器和负载均衡组件，部署应用所需的供应和联网服务，分配新的基础设施，设置监控和灾后恢复服务，日志聚合，当基础设施失效时重新部署应用。这些高级自动化实践，能把你从应对零日危险的痛苦中拯救出来：自动化采用滚动更新的方式，为每一个节点打上安全补丁，同时又保证服务一直在线。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>软件设计原则</title>
      <link>http://lanlingzi.cn/post/technical/2016/0306_arch_principle/</link>
      <pubDate>Sun, 06 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2016/0306_arch_principle/</guid>
      <description>&lt;p&gt;软件也像人一样，具有生命力，从出生到死亡，会经历多种变化。软件架构设计也不是一蹴而就的，是不断地演进发展。但为了能较好的发展，在软件设计时需要考虑一些原则。&lt;/p&gt;

&lt;h3 id=&#34;清晰原则-使用简洁接口-简单部件组合&#34;&gt;清晰原则：使用简洁接口，简单部件组合&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;编程的本质就是要控制复杂度，后期维护会占用大部分的时间。&lt;/li&gt;
&lt;li&gt;降低整体复杂度，用清晰的接口把若干简单模块组合成一个复杂的系统。&lt;/li&gt;
&lt;li&gt;对外隐藏细节，“不要与陌生人说话”。&lt;/li&gt;
&lt;li&gt;多数问题局限天一个局部，不要影响到全局。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结：本质是分而治之，复杂问题简单化，抽象框架，有序组全。
&lt;/p&gt;

&lt;h3 id=&#34;清晰原则-清晰胜于机巧&#34;&gt;清晰原则：清晰胜于机巧&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;代码直白易懂，代码是给人看的，不是给机器看的。&lt;/li&gt;
&lt;li&gt;维护代码的人，其中也你包括你自己，善待代码，就是善待自己。&lt;/li&gt;
&lt;li&gt;不要了一点性能提升而引入复杂的算法，不要为了炫耀技能而编写晦涩难懂的代码。&lt;/li&gt;
&lt;li&gt;复杂晦涩的代码是Bugs的温床，高昂的维护成本将抵消可怜的性能提升。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结：代码简洁晚懂，谨慎引入复杂度。&lt;/p&gt;

&lt;h3 id=&#34;简洁原则-设计简洁-降低复杂&#34;&gt;简洁原则：设计简洁，降低复杂&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;复杂问题简单化是一个设计者的能力体现，避免不必要的使用问题复杂化的因素。&lt;/li&gt;
&lt;li&gt;在市场导向下，在不良的架构上很容易堆砌花哨无用的新特性，导致软件趋于复杂。&lt;/li&gt;
&lt;li&gt;在进度压力下，不会做出各种折中的个性与不和谐的新特性开发。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结：过滤排序需求，追求稳定简洁。&lt;/p&gt;

&lt;h3 id=&#34;组合原则-组合-接拼-编排&#34;&gt;组合原则：组合，接拼，编排&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;把复杂问题分解为一条程序处理链条。&lt;/li&gt;
&lt;li&gt;程序之间可以通信，前者的输出是后者输入。&lt;/li&gt;
&lt;li&gt;通信方式尽量采用简单协议，并且与语言无关。&lt;/li&gt;
&lt;li&gt;组合程序之间无内部状态依赖，互相独立，处理链上下游不做假设，可替换。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结：面向微服务的设计。&lt;/p&gt;

&lt;h3 id=&#34;透明原则-设计与实现分离可见&#34;&gt;透明原则：设计与实现分离可见&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;设计简单，包括流程、数据结构、接口，在代码级别容易理解。&lt;/li&gt;
&lt;li&gt;支行时刻可通过输出信息或者接口查询运行状态，可控制程序是否正确运行。&lt;/li&gt;
&lt;li&gt;执行调试链、健康状态可跟踪、可分析。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结：简单设计，简明实现，状态监控。&lt;/p&gt;

&lt;h3 id=&#34;吝啬原则-除非别无它法-不要编写庞大的程序&#34;&gt;吝啬原则：除非别无它法，不要编写庞大的程序&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;程序庞大包括两个方面：程序体积大与程序复杂而维护困难。&lt;/li&gt;
&lt;li&gt;模块和函数尺寸都有一个上限，比如单模板代码10K，单函数100L。&lt;/li&gt;
&lt;li&gt;导致程序庞大的因素：先天设计不良，后天维护增加新特性。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结：合理设计，考虑扩展性，对庞大保护警惕。&lt;/p&gt;

&lt;h3 id=&#34;吝啬原则-有的放矢-按需分配资源&#34;&gt;吝啬原则：有的放矢，按需分配资源&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;若可能，当一个事情发生时候再分配资源，而不是预先分配，初始化时静态分配最小资源，随着业务动态增加资源分配。&lt;/li&gt;
&lt;li&gt;异步消息环境下，消息通信带来上下文切换，代价高昂。&lt;/li&gt;
&lt;li&gt;必要时对消息数据合并，打包发送，减少对网络资源的消耗。&lt;/li&gt;
&lt;li&gt;业务处理与消息发送分离，数据组织独立，统一打包发送。&lt;/li&gt;
&lt;li&gt;控制并发实例的数据，分批处理，防止下游过载各实例之间的恶性竞争通信资源。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结：按需分配资源，珍惜消息通信机会。控制并发，避免消息突发。&lt;/p&gt;

&lt;h3 id=&#34;健壮原则-健壮源于透明与简洁&#34;&gt;健壮原则：健壮源于透明与简洁&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;软件在超过设计者设想的意外场景下也能够运行良好。&lt;/li&gt;
&lt;li&gt;Bugs是一种异常，复杂性和特殊处理都是Bugs的温床。&lt;/li&gt;
&lt;li&gt;逻辑透明，接口简单有助于减少Bugs，即使出现Bugs也容易排除。&lt;/li&gt;
&lt;li&gt;软件设计时要考虑异常输入，边界条件，和过载场景。&lt;/li&gt;
&lt;li&gt;软件模块之间要处理流程上考虑能务匹配，流控，过载保护。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结：简单透明，处理能力匹配；考虑异常场景，提升健壮性；匹配上下游处理能力，闭环控制为主，开环控制为辅。&lt;/p&gt;

&lt;h3 id=&#34;表示原则-把知识叠入数据-简化统一处理逻辑&#34;&gt;表示原则：把知识叠入数据，简化统一处理逻辑&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;数据抽象建模，使用数据之间的关联关系来体现业务逻辑，或者领域知识，使得业务处理逻辑代码简单一致稳定。&lt;/li&gt;
&lt;li&gt;可通过修改数据模型可以支持新业务，逻辑处理代码不用修改。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结：领域模型驱动设计，数据数据提练来描述业务本质。&lt;/p&gt;

&lt;h3 id=&#34;缄默原则-只输出有用的信息&#34;&gt;缄默原则：只输出有用的信息&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;保持沉默，良好的行为是默默地工作，决不唠唠叨叨，碍手碍脚，程序也是如此。&lt;/li&gt;
&lt;li&gt;输出大量无用的信息会耗费资源，淹没重要信息，干扰维护人员定位问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结：沉默是金，惜时亦如金。输出的信息是必要的，有用的，不重复的。&lt;/p&gt;

&lt;h3 id=&#34;补救原则-异常时候-干净退出-输出详细信息&#34;&gt;补救原则：异常时候，干净退出，输出详细信息&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;当程序出现异常时，输出必要信息，使用简单方法结束。&lt;/li&gt;
&lt;li&gt;宽容地接受，严格地发送，提升程序的容错能力。&lt;/li&gt;
&lt;li&gt;程序要么正确执行，要么响亮倒塌。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结：看待这个问题一分为二，选择异常恢复方法要保证对用户的业务逻辑影响最小为基本原则。因此并不是说所有的异常都是进程退出重启，有时可以告警，事件通知，让管理员来处理，给出明确的修复方案说明。&lt;/p&gt;

&lt;h3 id=&#34;经济原则-宁花机器一分钟-不花程序员一秒&#34;&gt;经济原则：宁花机器一分钟，不花程序员一秒&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;对于一个问题，选择算法的时候宁愿选择一个简单，但可能是效率低一些的算法，也不要选择一个性能好但复杂度很高的算法。&lt;/li&gt;
&lt;li&gt;硬件的进步来弥补性能的下降，换来的是程序简单可靠，维护成本低。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结：辩证地看问题，选择简单，把复杂留给机器，解放程序员。&lt;/p&gt;

&lt;h3 id=&#34;生成原则-避免手工hack-让程序去生成代码&#34;&gt;生成原则：避免手工Hack，让程序去生成代码&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;人最不适合干大量重复细致的工作，或多或少都会出错，因此导致Bugs。&lt;/li&gt;
&lt;li&gt;与此相反，计算机最适合干规则明确，重复枯燥的工作，而且不会出错。&lt;/li&gt;
&lt;li&gt;对于一个规则明确的工作，一种可行的办法就是编写一个我程序，根据输入规则生成代码，让生成的代码去解决问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结：分析规则，能按照规则生成代码，可检查发现问题。&lt;/p&gt;

&lt;h3 id=&#34;优化原则-雕琢前先有原型-跑之前先学会走&#34;&gt;优化原则：雕琢前先有原型，跑之前先学会走&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;90%的功能能够实现，比100%功能永远不能实现要好得多。&lt;/li&gt;
&lt;li&gt;先求可行，再求正确，最后求快。&lt;/li&gt;
&lt;li&gt;原型可能有效地解决关键技术，保证系统是可以实现的。&lt;/li&gt;
&lt;li&gt;让客户看到可以执行的原型，对需求的理解更为准确，防止做无用功。&lt;/li&gt;
&lt;li&gt;过早优化是万恶之源，过早地优化会破坏程序结构，代码与数据结构杂乱无章；过早优化不清晰系统瓶颈，局部优化破坏整体优化。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结：性能是设计出来，不是优化来出来。&lt;/p&gt;

&lt;h3 id=&#34;多样原则-拒绝封闭和唯一&#34;&gt;多样原则：拒绝封闭和唯一&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;系统开放，只有开放，才能进步，才能得到最为广泛的验证。&lt;/li&gt;
&lt;li&gt;开放，可扩展，用户可定制，符合实际需求和获到高可靠性。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结：系统开发，留给用户定制空间，毕竟需求具体多样性，我们不能穷尽，最终只有用户才能准确理解自己的需求。&lt;/p&gt;

&lt;h3 id=&#34;同源原则-避免重复-数据同源&#34;&gt;同源原则：避免重复，数据同源&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;重复的代码不仅仅是浪费，也是Bugs的滋生之地。&lt;/li&gt;
&lt;li&gt;出现大段代码重复，说明开发者缺少对代码控制与抽象提炼能务，优秀的工程轻易不会在进度压力下让步。&lt;/li&gt;
&lt;li&gt;数据重复危害更大，一则浪费存储空间，二则容易出现不一致。&lt;/li&gt;
&lt;li&gt;在性能允许的情况下，尽量共享数据或者按需订阅，避免全量订阅。&lt;/li&gt;
&lt;li&gt;如果上述条件不具备，那么采用数据同源技术和一致性校验来保证数据的一致性。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结：拒绝重复，必须重复的时候考虑通过工具同源和一致性校验。&lt;/p&gt;

&lt;h3 id=&#34;扩展原则-设计时着眼未来-未来总比想象来得快&#34;&gt;扩展原则：设计时着眼未来，未来总比想象来得快&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;对于一个一次性的程序来讲，架构和设计只会带来成本上升，复杂度提高，与性能的下降。&lt;/li&gt;
&lt;li&gt;当开发一个支持多种产品的软件平台，其生命周期可能是十年以上。用户的需求是不断地变化，硬件环境也是不断地变化。&lt;/li&gt;
&lt;li&gt;只有适应变化，不能拒绝变化，可扩展性是软件非功能属性中，在大部分情况下排在可靠性，高性能之前&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结：不对外界进行假设，这些假设在时间面前都是脆弱的。&lt;/p&gt;

&lt;h3 id=&#34;扩展原则-给雪球寻找一个核心&#34;&gt;扩展原则：给雪球寻找一个核心&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;雪球都有一个内核，尽管可能是一粒不起眼的小石头。&lt;/li&gt;
&lt;li&gt;常说软件要内聚，内聚需要核心。&lt;/li&gt;
&lt;li&gt;微内核，插件化机制。框架即核心，框架之上定制好插件，构建系统。&lt;/li&gt;
&lt;li&gt;从问题知识域发现稳定部分进行抽象提升，成为系统的框架。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结：从框架的角度来看系统，框架之间的有机组合构建系统，系统的演化就是在框架稳定情况下增加替换相关的插件。&lt;/p&gt;

&lt;h3 id=&#34;扩展原则-扩展就是少修改&#34;&gt;扩展原则：扩展就是少修改&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;软件可扩展性是有前提和应用场景的，不存在可以随意扩展的软件。&lt;/li&gt;
&lt;li&gt;增加新功能做到不修改既有软件，代码无需修改，通过修改数据模型或者重新配置获得新特性。&lt;/li&gt;
&lt;li&gt;修改集中在新增加的软件之上，也就是说在增加新特性时，对老代码封闭，对新代码新特性开放。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结：系统开闭原则，修改对系统稳定不构成影响。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>