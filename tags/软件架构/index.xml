<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>软件架构 on 蘭陵N散記</title>
    <link>http://lanlingzi.cn/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/index.xml</link>
    <description>Recent content in 软件架构 on 蘭陵N散記</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <atom:link href="http://lanlingzi.cn/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>PaaS的发展</title>
      <link>http://lanlingzi.cn/post/technical/2017/0304_paas/</link>
      <pubDate>Sat, 04 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2017/0304_paas/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://lanlingzi.cn/images/paas/paas1.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;云计算按提供服务层次，通常划分为三层：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;IaaS ：基础构架即服务。这一层主要是对基础设施进行管理以给用户提供资源使用，如提供计算服务、安全备份、负载管理等。&lt;/li&gt;
&lt;li&gt;PaaS ：平台即服务。这一层主要是基于IaaS之上，简化应用的部署、维护等，提供一些通用平台软件能力，如数据挖掘、系统管理、编程模型等。&lt;/li&gt;
&lt;li&gt;SaaS ：软件即服务。这一层主要是面向终端客户，提供一站式的解决方案。如提供CRM、HRM、SCM等，是可以直接使用其服务。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;个人一直从事PaaS的研发，而我们做的又是面向电信领域的PaaS。与外面的朋又交流发现，大家对PaaS的理解是不一样的，主要还是由于PaaS的本质是要解决的问题是：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;简化开发，打通DevOps，实现业务应用的敏捷与弹性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;不同的业务领域，要面对是&lt;code&gt;不同的传统应用架构如何通过PaaS平台迁移到云上&lt;/code&gt;，这就会导致各自对PaaS的需求或多或少有着不同的差异，理解不一样也是正常的。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;paas定义&#34;&gt;PaaS定义&lt;/h2&gt;

&lt;p&gt;NIST（National Institute Of Standards and Technoloy）曾对PaaS有过经典的定义：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;面向应用的核心平台，封装应用分布式复杂性，实现应用层自动化、高可用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;从功能定义来看，主要包含三个方面：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;应用托管：可将开发者创建或拥有的应用部署到云基础设施上。其价值是应用对基础设施资源的获取自动化。&lt;/li&gt;
&lt;li&gt;应用开发：开发者使用供应商提供的运行环境，编程语言框架，服务以及工具等来构建应用。其价值是应用对中间件服务的获取自动化，软件开发自动化。&lt;/li&gt;
&lt;li&gt;应用运维：应用的运维无需管理或控制底下的基础设施（计算、网络、存储、OS等），可以控制已部署的应用，并有可能对应用托管的环境、其配置进行控制。其价值是应用的运维管理（伸缩，配置，升级等）自动化。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以PaaS是以应用开发为中心，解决如下三个问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;应用全生命周期管理：从应用的开发、部署，到运维的全流程生命周期管理。开发者可使用供应商提供的运行环境，编程语言框架，服务与工具等快速构建应用；通过平台将应用部署到云基础设施上，并对应用进行自动伸缩，弹性扩展，灰度发布等；对上线的应用可以实现监控管理，故障分析，自动迁移，自动恢复，为应用提供高用性，高可扩展性。&lt;/li&gt;
&lt;li&gt;中间件云服务：提供丰富的预集成服务，如分布式数据库服务，分布式消息队列服务，分布式缓存服务等。把通用的软件能力服务化，使得应用能快速拥有分布式的高用性，高可扩展性。同时中间件服务让多租能力变得可行，在中间件云服务层，不同的租户可参共享或隔离不同的服务资源。&lt;/li&gt;
&lt;li&gt;基础资源的高效利用：对底层资源的抽象，可以按用户要求分配的相应用资源部署实例。大规模的应用部署在云基础设施上，PaaS可能通过调度算法，把应用实例调度到不同的资源上运行。通过资源层的隔离，尽可能地共享或平摊资源，以提高资源整体使用率，从而降低基础设施的投入。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;paas的发展历史&#34;&gt;PaaS的发展历史&lt;/h2&gt;

&lt;p&gt;早期公有云，主要是提供高效多语言多框架的开发与运维环境：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;2005年，Rackspace，提供托管PHP与.Net语言的Web应用，不支持多租户，API和自动伸缩。&lt;/li&gt;
&lt;li&gt;2007年，Heroku/Force.com，支持Ruby语言，引进数据库，企业工作流服务，主要是支持托管CRM相关的应用。&lt;/li&gt;
&lt;li&gt;2008年，GAE, Google发布面向WEB的开发和托管的平台，早期支持python、java语言。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;开源PaaS成长期，主要是提供应用快速部署到基础设施上的能力：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;2008年，CloudFoundry，提供支持多语言，多框架的可移植的PaaS平台。2011年被VMWare收获，其后开源。&lt;/li&gt;
&lt;li&gt;2010年，OpenShift，Redhat发布OpenShift，支持多种异构I层。受2011的CloudFoundry，也开源。&lt;/li&gt;
&lt;li&gt;2010年，Cloudify，Gigaspace开始基于Java构建支持多种异构I层的PaaS，重点在应用部署，并开源。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在2014年之后，PaaS也不在仅仅是互联网的公有云玩法，而是百花齐放。软件开发管理模式正在PaaS技术的驱动下，经历一场新的变革：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;传统软件巨头份份杀人：Oracle，SAP，IBM，HP等发布云战略，构建PaaS平台，极力在其各自的传统领域打造云生态系统。&lt;/li&gt;
&lt;li&gt;公有云PaaS呈现三国鼎立：AWS， Azure与GAE的PaaS平台走向成熟，构建方式呈现多层次，应用可以按需组合；并且在提供的服务数量，服务性能不断提升。&lt;/li&gt;
&lt;li&gt;PaaS开源项目爆发：早期的CloudFoundry，OpenShift，Cloudify历经多个版本也走向成熟；轻量级的PaaS不断涌现，如Apache Stratos, Deio, Flynn等；面向应用与资源调度的PaaS开源抢占风头，Docker，CoreOS, Mesos, Kubernetes。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以说，当前的PaaS也不在局限于NIST的经典定义，而是在大规模的云基础设施上，提供更多的高性能的云服务，更高效的资源使用方式。PaaS已经呈现多样形态，在灵活性和易用性上不断地提升。同时多形态并存，但也没有一个形态可以满足所有用户需求。&lt;/p&gt;

&lt;h2 id=&#34;paas的发展趋势&#34;&gt;PaaS的发展趋势&lt;/h2&gt;

&lt;p&gt;随着新技术的出现，目前PaaS的发展趋势主是容器化，微服务化，分布式化。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;容器化&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Docker简化了软件打包，形成了新的软件分发标准；同时解决了应用环境的一致性，加快了应用的部署，DevOps; Docker能更粒度地的资源分割。这些特性使得Docker技术快速应用，其技术以及生态的发展正对PaaS产生革命性的冲击与影响。基于Docker的PaaS平台也是层出不穷，如OpenShift，CloudFoundry，Deis与Flynn等，而公有云AWS， Azure，GCE与IBM等都份份支持Docker容器。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;微服务化&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;传统的集中式的三层架构，转变到微服务架构。应用由一组无状态，功能分离，可独立部署的小服务集组合而成。而每个服务又具体语言多样性，不同的开发团队可以选择其熟悉与场景适合的语言。服务间是解耦合的，每个服务内部可能快速上线，而不影响其它的服务。某个服务的故障只会影响到自己。微服务化架构下，PaaS平台要支持对微服务架构的应用平滑地演进。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;分布式化&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;传统PaaS面临着缺少大规模跨DC跨集群的管理能力；资源分配算法比较简单，不支持应用感知的多集群等资源分配需求；资源分配并行技术缺少在大量资源需求时验证，分配速度不理想。但无论是公有云还是私有云大规模地发展，都驱动了大规模集群管理与资源跨Region跨DC跨AZ调度。当前基于容器集群管理编排、资源调度技术还在不断地演进发展。&lt;/p&gt;

&lt;h2 id=&#34;paas构建新目标&#34;&gt;PaaS构建新目标&lt;/h2&gt;

&lt;p&gt;应用敏捷性，集中式朝分布式架构演进，构建PaaS时需考虑如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;PaaS支持应用渐进式地演进：构建基础通用技术共享平台（如微服务框架，DevOps流水线，通用中间件服务等），逐步迁移改造应用，让应用更好地Cloud Native。&lt;/li&gt;
&lt;li&gt;PaaS支持应用的高用性：基于Design for failure理念，构建基础的可靠性工具集，通过软件来实现应用层的高可用性，支持跨DC，AZ等高用性部署；支持跨2地3中心的高可用性路由；支持应用分布式下事务管理，数据的一致性等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;大规模的基础设施建设，需要打通IaaS/PaaS，构建基于应用层的统一资源编排调度：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;全自动化：支持应用自动化部署，伸缩，灰度发布等；开发环境的自助式获取与应用自动化验证。&lt;/li&gt;
&lt;li&gt;混合调度：支持基于物理机，虚拟机，以及容器在应用层的不同需求下的混合调度。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;开放性才能让PaaS更具有生命力，PaaS需易集成，无锁定，让应用可以快速平滑迁移：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;多IaaS： 公有层场景下，可能由PaaS供应用商自建IaaS。但在私有云场景下，支持多IaaS对接是非常有价值的。&lt;/li&gt;
&lt;li&gt;多运行环境： 微服务化，不同的服务可能采用不语言开发，这要求PaaS支持多语言的运行环境。&lt;/li&gt;
&lt;li&gt;多服务：无论是平台本身提供的中间件云服务，PaaS还要能支持第三方传统服务的接入以供应用使用。&lt;/li&gt;
&lt;li&gt;多工具：目前开源的自动化工具非常多，PaaS平台需要考虑支持可以集成多种工具，拉通现有应用的DevOps。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Design for Failure</title>
      <link>http://lanlingzi.cn/post/technical/2017/0216_dff/</link>
      <pubDate>Thu, 16 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2017/0216_dff/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://lanlingzi.cn/images/dff/dff.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;

&lt;p&gt;故有的思维会影响创新，在传统的软件设计考虑高可靠性，主要方法论是”防“，处处保护，让系统的每一处能长时间运行，不中断地提供服务。事实上电信级高可用性（HA）也只能宣称达到5个9，这意味着一年也就只有5分半钟的中断时间。但每增加一个9却实施成本非常地高，有些是建立在硬件可靠基础之上，并且不少是实验数据或理论上支持。传统的思维认识，在泥沙上建房子不可靠的。但软件架构设计，即完全不一样，在不可靠的基础设施上构建上可靠的系统，那才是真正NB的。&lt;/p&gt;

&lt;p&gt;依稀记得云计算刚出来时，大家都是持怀疑态度：性能下降的虚拟化技术、安全不可控的网络、变化复杂的资源管理，在其上如何构建可靠稳定的软件系统？事实上，Netflix完全基于AWS云基础设施，认为都有可能发生任何的故障（Failure），更何况资源也不掌握在自己手上。Netflix基于&lt;code&gt;Design for Failure&lt;/code&gt;理念却构建出用户无感知的高可用系统，支撑他的业务飞速发展。事实上，故障无所不在，尤其是在云计算环境中：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;资源层次：电能失效，整个数据中心不可用；部分计算失效，网络不通，存储IO高等&lt;/li&gt;
&lt;li&gt;应用层次：资源泄露；软件Bug；系统处理能力不足等&lt;/li&gt;
&lt;li&gt;数据层次：数据丢失；数据不一致等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;概念解读&#34;&gt;概念解读&lt;/h2&gt;

&lt;p&gt;既然故障不可避免，何不让故障尽早的暴露，尽快的恢复。设计时针对故障场景而设计，一切假定在故障失效下如何处理，局部的失效不影响整体的可用性。这就是&lt;code&gt;Design for Failure&lt;/code&gt;的核心理念。这个设计理念其实也跟人类社会很像：一个人的细胞代谢，只要有新的细胞补上就行；一个组织中，高度细分工作，几个人的离开，不影响整体的运转。&lt;code&gt;Design for Failure&lt;/code&gt;不仅仅是高可用性设计，而是一种新的设计理念，有别于传统，通过单点的可靠性达到整体的高可用性。以Netflix公布的数据来看，每个EC2实例平均生命周期只有36个小时，每个单点不断地重生，才能达到整体的高可用性。其关键实施要点总结如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;容错：当系统中出现了各种故障时，系统能够自动隔离故障而不影响系统对外的服务质量。&lt;/li&gt;
&lt;li&gt;冗余：提供系统冗余配置，当系统发生故障时，冗余的快速介入并承担已发生故障的工作。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以一个运行在云环境中的应用为例，&lt;code&gt;Design for Failure&lt;/code&gt;理念需要按如下步骤来考虑：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;每个应用程序组件必须部署在冗余的云组件/服务上，有很少或没有失败的共同点，即不存在单点故障；&lt;/li&gt;
&lt;li&gt;每个应用组件必须对基础设施不作任何假设，它必须能够在不停机的情况下适应基础设施的变化；&lt;/li&gt;
&lt;li&gt;每个应用程序组件应该是分区容忍，换句话说，它应该能够生存的网络延迟（或通信损失）的节点上；&lt;/li&gt;
&lt;li&gt;借助于自动化工具，必须能编排应用程序，以便响应失败或其他基础设施的变化等等。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;案例分析&#34;&gt;案例分析&lt;/h2&gt;

&lt;p&gt;一个单点的故障，我们可能针对性地很容易解决，这可能是头痛医头的做法。但一个系统软件往往没有那么简单，举例来说，一个汽车生产线，生产不同的汽车，需要使用不同的零件，如果某个零件因为种种原因无法使用，那么就会造成整台车无法装配，陷入等待零件的状态，直到零件到位，才能继续组装。 此时如果有很多个车型都需要这个零件，那么整个工厂都将陷入等待的状态，导致所有生产都陷入瘫痪。一个零件的波及范围不断扩大。这就是我们常说的&lt;code&gt;雪崩效应&lt;/code&gt;。所以我们非常有必要分析系统中的各种依赖关系。不同的层次来&lt;code&gt;Design for Failure&lt;/code&gt;，不同的技术组合来解决问题。&lt;/p&gt;

&lt;p&gt;以Netflix的系统架构来简单分析一下，看它是如何分层解决问题的：&lt;/p&gt;

&lt;h3 id=&#34;接入层&#34;&gt;接入层：&lt;/h3&gt;

&lt;h4 id=&#34;aws-elb&#34;&gt;AWS ELB&lt;/h4&gt;

&lt;p&gt;典型的部署架构都是多地区（Region）、多可用区（Zone）的部署。负责四层负载分发，支持跨Region调用，它解决是当一个Region不可用的分发。&lt;/p&gt;

&lt;h4 id=&#34;zuul&#34;&gt;Zuul&lt;/h4&gt;

&lt;p&gt;Zuul负责七层分发，提供动态路由，监控，弹性，安全等。Zuul可以通过加载动态过滤机制，从而实现以下各项功能：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;验证与安全保障: 识别面向各类资源的验证要求并拒绝那些与要求不符的请求；&lt;/li&gt;
&lt;li&gt;审查与监控: 在边缘位置追踪有意义数据及统计结果，从而为我们带来准确的生产状态结论；&lt;/li&gt;
&lt;li&gt;动态路由: 以动态方式根据需要将请求路由至不同后端集群处；&lt;/li&gt;
&lt;li&gt;压力测试: 逐渐增加指向集群的负载流量，从而计算性能水平；&lt;/li&gt;
&lt;li&gt;负载分配: 为每一种负载类型分配对应容量，并弃用超出限定值的请求；&lt;/li&gt;
&lt;li&gt;静态响应处理: 在边缘位置直接建立部分响应，从而避免其流入内部集群；&lt;/li&gt;
&lt;li&gt;多区域弹性: 跨越AWS区域进行请求路由，旨在实现ELB使用多样化并保证边缘位置与使用者尽可能接近；&lt;/li&gt;
&lt;li&gt;金丝雀测试：金丝雀版本实现精确路由；&lt;/li&gt;
&lt;li&gt;故障注入：结合故障注入工具，从前端自动注入故障；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;服务层&#34;&gt;服务层&lt;/h3&gt;

&lt;h4 id=&#34;eureka&#34;&gt;Eureka&lt;/h4&gt;

&lt;p&gt;Eureka为所有Netflix服务提供服务注册集中管理，当然它也是可以分Zone分Region集群部署的。它与Zookeeper不同是：Zookeeper侧重于CP，而Eureka侧重于AP；服务注册信息支持跨Region的复制。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Eureka服务端用作服务注册，提供服务实例信息注册与同步；&lt;/li&gt;
&lt;li&gt;Eureka客户端用用服务发现，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;ribbon&#34;&gt;Ribbon&lt;/h4&gt;

&lt;p&gt;由于Eureka是非强一致性，服务实例状态并非是实时性，服务调用可能失败或超时。所以Ribbon作为客户端组，配合Eureka一起使用，作为服务路由均衡的补充。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ribbon客户端提供一系列完善的配置选项，比如连接超时、重试、重试算法等，&lt;/li&gt;
&lt;li&gt;Ribbon内置可插拔、可定制的负载均衡组件，支持多种均衡策略：简单轮询负载均衡；加权响应时间负载均衡；区域感知轮询负载均衡；机负载均衡。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在选择服务器时，该负载均衡器会采取如下步骤：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;负载均衡器会检查、计算所有可用区域的状态。如果某个区域中平均每个服务器的活跃请求已经达到配置的阈值，该区域将从活跃服务器列表中排除。如果多于一个区域已经到达阈值，平均每服务器拥有最多活跃请求的区域将被排除。&lt;/li&gt;
&lt;li&gt;最差的区域被排除后，从剩下的区域中，将按照服务器实例数的概率抽样法选择一个区域。&lt;/li&gt;
&lt;li&gt;从选定区域中，将会根据给定负载均衡策略规则返回一个服务器。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;hystrix&#34;&gt;Hystrix&lt;/h4&gt;

&lt;p&gt;Hystrix提供分布式系统使用，提供延迟和容错功能，隔离远程系统、访问和第三方程序库的访问点，防止级联失败，保证复杂的分布系统在面临不可避免的失败时，仍能有其弹性。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;隔离模式：简单说就是为每个依赖调用分配一个小的线程池，如果线程池已满调用将被立即拒绝，默认不采用排队，加速失败判定时间。&lt;/li&gt;
&lt;li&gt;熔断模式：目标服务调用慢或者有大量超时，此时，熔断该服务的调用，对于后续调用请求，不在继续调用目标服务，直接返回，快速释放资源。如果目标服务情况好转则恢复调用。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上述两种模式的实施，是服务速错，服务降级的基础。&lt;/p&gt;

&lt;h3 id=&#34;数据层&#34;&gt;数据层&lt;/h3&gt;

&lt;h4 id=&#34;evcache&#34;&gt;EVCache&lt;/h4&gt;

&lt;p&gt;VCache是一个数据缓存服务，专门为Netflix的微服务提供低延迟，高可靠性的缓存解决方案。它是基于memcached的内存存储，专门为云计算优化，适合对强一致性没有必须要求的场合。它不需要处理全局锁，群体读写，事务更新，部分提交和回滚，和其他一些分布式一致性的复杂设计。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;跨区可用：一个地区的的会员切换到另外一个地区，会在新的地区缓存中没有老地区的数据，称为cold cache，缓存会保存着重新计算需要的临时数据，这些数据如果从持久层存储获得将会非常昂贵，所以这种数据写入到本地缓存，并必须复制到所有地区的缓存中，以便服务于各个地区会员使用。&lt;/li&gt;
&lt;li&gt;复制延迟：在跨区域复制变慢的情况下，不会影响性能和本地缓存的可靠性，所有复制都是异步的，复制系统能够在不影响本地缓存操作情况下悄悄地短时间中断。不需要一个完美的复制系统，可以接受EVcache一定限度的延迟和不一致，只要能满足应用和会员的需要就行。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;其它&#34;&gt;其它&lt;/h4&gt;

&lt;p&gt;Cassandra是一个NoSQL数据库，是购买一家商业公司的服务，主要是用于各种Session的存储，并且支持跨区的同步复制。S3主要用于数据的备份。&lt;/p&gt;

&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;Netflix在每层上都考虑了失效，如何处理，但它每一层都没有做到尽善尽美，但不同层次的组合，却做到几乎完美的高可用性。当然Netflix构建高用性的系统还不只是我上面所列出的组件或工具。列出关键的部分是为了表达出&lt;code&gt;Design for Failure&lt;/code&gt;的理念是：故障不可避免，可以分层次的设计，通过多个技术方案组合应用，从而达到故障隔离，冗余恢复，实现整体的高可用性。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>再说说微服务</title>
      <link>http://lanlingzi.cn/post/technical/2017/0207_msa_think/</link>
      <pubDate>Tue, 07 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2017/0207_msa_think/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://lanlingzi.cn/images/msa/timg.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;why&#34;&gt;Why&lt;/h2&gt;

&lt;p&gt;我司从15年开始学习互联网的微服务构架，到今16年的全云化战略，微服务已作为架构体系的重要工作。但微服务看似美好，在IT界应用非常的成熟与成功，但这个本质没有革命性的技术架构，在我司却非常地难以落地。主要原因：传统的CT应用太过厚重，面临着软件交付模式完全不一样，历史包袱改造面临短期看不到收益的成本投入：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;IT界：软件是自运维，借助于微服务构架，DevOps工程化，以及相对扁平的组织结构。软件向微服务转变相对阻力比较小，按康威定律，组织决定架构，微服务构架与扁平化、轻小的、精英化的组织是完全匹配的。在微服务构架实施上可以快速迭代演进，同时形成回路反馈，架构更符合良性的发展。同时像BAT等公司，业务上爆发式的增涨，也会加速微服务构架软变与满足。&lt;/li&gt;
&lt;li&gt;我司：软件非自运维，做的是产品卖给运营商，DevOps当前无法直接打通。微服务构架对交付与运维来说，没有直接带来价值，反而会带来更多的问题。运营商是不可能像IT界每日构建灰度升级的。当然运营商自己也在改变，但这个改变是基础设施平台化，上层业务应用会拉入IT厂商，反而像我司这类传统的设备供应商会被旁落。说起来，这是另一个更大沉重的话题，不就再展开了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;what&#34;&gt;What&lt;/h2&gt;

&lt;p&gt;微服务架构转变当前遇到的各种问题，不是我们不实施微服务架构的理由。软件全云化，微服务这是趋势。再说说微服务对我们目前软件开发的核心价值吧：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;设计：微服务架构下，设计上可以重用已有微服务，反哺微服务仓库，达到软件功能更好的复用；同时由于微服务具有9大特性，使架构师能更好的守护软件架构。&lt;/li&gt;
&lt;li&gt;开发：相比原来组件化架构，每个开发人员负责的代码量减少，更能把事件做精；微服务架构下，一般会有像JDF或HSF的服务框架，使开发难度降低；业务功能的细分，基于服务化接口契约，使并行开发变成可能，工期缩短；细粒度快速验证，单个微服务的更容易稳定。&lt;/li&gt;
&lt;li&gt;部署：基于微服务的功能组合，可以按不同的特性交付，特性独立上线，而不原有的通过License开关控制；容量上可以按小颗粒度，自动化地伸缩，系统拥有更好的弹性。&lt;/li&gt;
&lt;li&gt;运行：可以小颗粒度，自动化地故障隔离，故障影响范围可控；按服务的滚动升级。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有上面的这些理由，难道我们还不选择微服务架构吗？架构上是OK的，但我司的矩阵性管理，有项目经理，有产品管理，有服务人员，有部门经理，有成本管理等，他们会看到，会认可吗？会有产品上收益来支撑吗？遗憾是目前没有，所以仅仅是研发体系上的隐性收益很难快速地推进。&lt;/p&gt;

&lt;h2 id=&#34;how&#34;&gt;How&lt;/h2&gt;

&lt;p&gt;在我司，那如何地渐进式地推进微服务架构，从四个维度架构视图展开：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;逻辑视图：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;存量代码按特性功能进行分析梳理，优先有商业价值的特性功能重构&lt;/li&gt;
&lt;li&gt;将老版本进程进行拆分与整合，对于相对稳定的原有组件尽量只服务化，而不微服务化&lt;/li&gt;
&lt;li&gt;新增特性直接按照微服务架构设计，并优先考虑重用已有拆分的微服务&lt;/li&gt;
&lt;li&gt;服务独立自治，多实例集群负荷均衡，可靠性服务内完成，服务内性能并发，服务使用者性能透明&lt;/li&gt;
&lt;li&gt;去中心化治理，无全局控制节点，避免全局故障&lt;/li&gt;
&lt;li&gt;服务划分原则：数据私有化，功能实例化，接口标准化，依赖最小化&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;部署视图：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;独立进程承载服务功能，在部署形态上做到可分可合&lt;/li&gt;
&lt;li&gt;服务尽量部署独立数据库，在设计上考虑Schema的隔离&lt;/li&gt;
&lt;li&gt;服务内的多进程统一服务控制节点管理&lt;/li&gt;
&lt;li&gt;服务可靠性，并发性统一由服务控制节点管理&lt;/li&gt;
&lt;li&gt;改造老进程新增服务接口，新老并存，调通后再去除老接口&lt;/li&gt;
&lt;li&gt;新服务新进程承载，调通后替换老进程&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;开发视图：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;按照服务构建开发视图&lt;/li&gt;
&lt;li&gt;按照服务构建测试工程&lt;/li&gt;
&lt;li&gt;按照服务适配个人构建&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;能力视图：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;配置能力完善，包括基础架构，研发工具，人员能力&lt;/li&gt;
&lt;li&gt;探索适合我司交付模式的微服务的开发模式&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总之，微服务架构落地不可能一蹴而蹴，更不可能一场运行就能解决的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>CloudNative初探</title>
      <link>http://lanlingzi.cn/post/technical/2017/0106_cloudnative/</link>
      <pubDate>Fri, 06 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2017/0106_cloudnative/</guid>
      <description>&lt;p&gt;随着日益普及的云计算，越来越多的传统应用迁移到云上。尤其是视频巨头NetFlix从2009年开始，放弃构建自己的数据中心，把所有应用迁移到AWS。NetFlix认为云环境下，everything will be failure。它基于微服务架构，以及Design for failure理论，构建出一系统非常成功的云应用（微服务），支持它的业务飞速发展。NetFlix认为他们比Amazon自己更懂得AWS。同时业界也提出了CloudNative概念，Netflix的应用也认为目前最为成功的CloudNative应用（参考&lt;a href=&#34;http://www.slideshare.net/adrianco/netflix-what-changed-gartner-catalyst&#34;&gt;Cloud Native at Netflix&lt;/a&gt;）。那什么是CloudNative？&lt;/p&gt;

&lt;h2 id=&#34;概念&#34;&gt;概念&lt;/h2&gt;

&lt;p&gt;目前对CloudNative并没有明确的定义。15年，Google联合其他20家公司宣布成立了开源组织Cloud Native Computing Foundation（CNCF）。想通过开源的Kubernetes，在云计算领域占据主层地位。当然Kubernetes目前是一个以应用为中心容器编排，调度集群管理系统。它想做的是CloudNative Application的基石。从CNCF组织来看，CloudNative Application应该包含微服务，容器，CI/CD特征。&lt;/p&gt;

&lt;p&gt;早在2010年，WSO2的联合他始人Paul Fremantle在业界最早提出&lt;a href=&#34;http://wso2.com/library/articles/2010/05/blog-post-cloud-native/&#34;&gt;CloudNative，认为有如下几个关键特征&lt;/a&gt;：
&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Distributed/Dynamically wired，分布式/动态连接&lt;/li&gt;
&lt;li&gt;Elastic，弹性；Scale down as well as up, based on load，基于系统负载的动态伸缩&lt;/li&gt;
&lt;li&gt;Granularly metered and billed，粒度合适的计量计费；Pay per user，按使用量计费&lt;/li&gt;
&lt;li&gt;Multi-tenant，多租户&lt;/li&gt;
&lt;li&gt;Self service，自服务&lt;/li&gt;
&lt;li&gt;Incrementally deployed and tested， 增量的部署与测试&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CloudNative系统的效果： Better utilization of resources, faster provisioning, better governace。&lt;/p&gt;

&lt;p&gt;在2013年，AWS的云战略架构师同时也是NetFlix的云架构师Adrian Cockcroft提出对&lt;a href=&#34;https://www.infoq.com/presentations/migration-cloud-microservices&#34;&gt;CloudNative新的定义&lt;/a&gt;：基于不可靠的，易失效的基础设施(ephermeral and assumed broken components), 构建高度敏捷（high agile），高可用（highly available）的服务，包括如下几个方面：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;目标：Scalability，伸缩性；Availablility，可用性；Agile，敏捷；Efficiency，效率&lt;/li&gt;
&lt;li&gt;原则：Separation of Concerns，关注点分离；Anti-Fragility，反脆弱性；High trust organization，高度信任的组织&lt;/li&gt;
&lt;li&gt;特点：Public Cloud，基于公有云； Mirco-services，微服务；De-normalized data，反范式化数据；Chaos Engines，混沌引擎；Continues Deployment，持续部署；DevOps等等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在2015年，Pivotal的产品经理Matt Stine又对&lt;a href=&#34;http://www.infoq.com/cn/articles/cloud-native-architectures-matt-stine&#34;&gt;CloudNative关键架构特征&lt;/a&gt;进行补充：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://12factor.net/&#34;&gt;Twelve Factor App&lt;/a&gt;，十二因子应用&lt;/li&gt;
&lt;li&gt;Mirco-services，微服务&lt;/li&gt;
&lt;li&gt;Self Service Agile Infrastructure，自服务敏捷的基础设施&lt;/li&gt;
&lt;li&gt;API Based Clolaboration， 基于API的协作&lt;/li&gt;
&lt;li&gt;Anti-Fragility，反脆弱性&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;总结起来，要实施CloudNative，包括三个维度：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;软件架构：基于敏捷基础设施，是整个Cloud Native的根基；基于微服务架构，微服务架构是Cloud Native的一个核心要素；基于Design for failure理论，构建高可用的系统；基于容器部署，确保环境一致性，应用快速启动终止，水平扩展。&lt;/li&gt;
&lt;li&gt;组织变革：根据康威定律，如果要达到比较理想的云化效果，必须进行组织变革。一个合理的组织架构，将会极大提高云化的推行；推行DevOps文化，倡导开放、合作的组织文化。&lt;/li&gt;
&lt;li&gt;软件工程：推行持续集成与持续交付，联合开发、质量、运维各个环节，打通代码，编译，检查，打包，上线，发布各个环节。全自动化，包括自动化部署，升级，灰度，以及运维。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CloudNative背后的软件架构需求：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;按需特性的伸缩&lt;/li&gt;
&lt;li&gt;按特性持续演进&lt;/li&gt;
&lt;li&gt;应用快速上线&lt;/li&gt;
&lt;li&gt;系统的高用性&lt;/li&gt;
&lt;li&gt;全面解耦合&lt;/li&gt;
&lt;li&gt;系统自服务&lt;/li&gt;
&lt;li&gt;支持多租户&lt;/li&gt;
&lt;li&gt;异构公有云&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;参考：&lt;br /&gt;
1. &lt;a href=&#34;http://wso2.com/library/articles/2010/05/blog-post-cloud-native&#34;&gt;http://wso2.com/library/articles/2010/05/blog-post-cloud-native&lt;/a&gt;&lt;br /&gt;
2. &lt;a href=&#34;https://www.infoq.com/presentations/migration-cloud-microservices&#34;&gt;https://www.infoq.com/presentations/migration-cloud-microservices&lt;/a&gt;&lt;br /&gt;
3. &lt;a href=&#34;http://www.infoq.com/cn/articles/cloud-native-architectures-matt-stine&#34;&gt;http://www.infoq.com/cn/articles/cloud-native-architectures-matt-stine&lt;/a&gt;&lt;br /&gt;
4. &lt;a href=&#34;http://www.open-open.com/lib/view/open1447420363069.html&#34;&gt;一篇文章带你了解Cloud Native&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>要学会思维图形化</title>
      <link>http://lanlingzi.cn/post/thoughts/2016/1118_arch_drawing/</link>
      <pubDate>Fri, 18 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/thoughts/2016/1118_arch_drawing/</guid>
      <description>&lt;p&gt;曾经，我幼稚地认为：只有写好代码才能对产品最“大”的贡献。什么需求分析文档，架构设计文档，没有最终的代码落地，那就是一张张的空纸。那些职位高高在上的架构师们，就也是写写胶片，画画图，他们又不懂技术细节，天天开会讨论来，讨论去都是在空谈一切。没有我们这些屌丝写的代码，你让他们去实现，估计几年也搞不出来。我写代码的能力比他们顶上N个人；再看看人家老外，60/70岁了还在码代码。为什么我国到了30岁了，都不去写代码了，都去搞所谓的架构设计了。是他们写代码写不好才去干架构师活吗？&lt;/p&gt;

&lt;p&gt;经过这么多年在产品中挖坑、填坑，发现我们的产品是越来越复杂，但使用上也是越来越复杂，问题也是越来越难理清。我们的问题到底是出在什么地方：
&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数据不可靠，系统常出错&lt;/li&gt;
&lt;li&gt;增加新需求困难，场景总是覆盖不全&lt;/li&gt;
&lt;li&gt;系统之间集成各种问题难以轻易解决&lt;/li&gt;
&lt;li&gt;交付不同局点，代码总是改来改去&lt;/li&gt;
&lt;li&gt;每年代码量成倍增加，前辈的代码看不懂、改不动&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这其实是光写好代码是不能解决上述问题的。只有你经历过，感受到，才能认识到系统的架构是何其重要。作为曾经一名码农，这几年一直在设计部与架构部工作，总是羡慕那些高级别的架构师：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;他们思考问题角度完全不同，总能高屋建瓴概括总结&lt;/li&gt;
&lt;li&gt;他们思考问题比较全面，又能抽象提炼，让人快速抓住要要点&lt;/li&gt;
&lt;li&gt;他们们输出的胶片、图画非常简洁，优美，明了，无二义&lt;/li&gt;
&lt;li&gt;他们画出来图来指导解决集成问题，往往能一针见血地说明关键之处&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为什么他们的图能画得那么好，胶片写得那么牛，而我们似乎绞尽脑汁也难画出一张满意的图，难写出几张像样的胶片，是什么原因？是画得太少，写得太少，经验不足，方法不对，无灵感，还是天赋？&lt;/p&gt;

&lt;p&gt;看到&lt;a href=&#34;https://zhuanlan.zhihu.com/intelligence&#34;&gt;采铜&lt;/a&gt;老师的文章才悄然大悟：原来，&lt;strong&gt;不仅是因为架构师需要丰富的实践经验、敏锐的分析能力，以及系统性的建模能力&lt;/strong&gt;，更主要的是因为：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;日常我们通过文字/讲故事是线性叙述，是人和时间的结合；而画图，是人与空间结合，理有助于思维拓展&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;推荐阅读：&lt;br /&gt;
[1] &lt;a href=&#34;https://zhuanlan.zhihu.com/p/19874517&#34;&gt;思维运筹学导论（原理篇）&lt;/a&gt;&lt;br /&gt;
[2] &lt;a href=&#34;https://zhuanlan.zhihu.com/p/19888228&#34;&gt;思维运筹学导论（实践篇 · 图形化 · 上）&lt;/a&gt;&lt;br /&gt;
[3] &lt;a href=&#34;https://zhuanlan.zhihu.com/p/19891814&#34;&gt;思维运筹学导论（实践篇 · 图形化 · 下）&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>软件变革下设计原则</title>
      <link>http://lanlingzi.cn/post/technical/2016/0910_soft_design/</link>
      <pubDate>Sat, 10 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2016/0910_soft_design/</guid>
      <description>&lt;p&gt;传统大型软件系统 ，多以功能需求驱动设计与开发。在体系结构上是一个单体应用，变更修改往往是牵一而发动全身；在系统生态上是一个封闭系统，系统集成是大量定制开发。单体封闭的系统在交付中面临着越来越多的挑战，提升系统的竞争力首先是在软件架构上先行。软件系统发展也需像硬件一样不断地更新换代，软件架构设计需要输入新的思维。只有在思想上彻底地变革，才能摆脱原有的束缚与局限性。&lt;/p&gt;

&lt;h2 id=&#34;体验为王&#34;&gt;体验为王&lt;/h2&gt;

&lt;p&gt;软件原本是一种信息技术发展不断地服务于各行各业，软件在实现上又是偏向技术性。如何让普通用户能够较好地使用软件，而不需要这方面的专业背景，需要思考软件减少数字与体验之间鸿沟。互联网思维一直讲求如何让用户感知到你对他的价值，而且把这个价值争取做到极致，超出用户的预期，这个就叫体验。只有用户产生体验之后，才能形成口碑。简而言之，体验的思想，就是从用户的感受出发，把它做到极致。
&lt;/p&gt;

&lt;p&gt;正如我们所见到的，iPhone的成功原因之一，就是注重用户的体验获得巨大的成功。今天，人们于弹指间操控丰富业务。无数应用，以碎片化的形式填满用户时间，连接起永远在线的数字生活。一个显见的事实是，“体验”正被尊奉为至高无上的法则，用户已重掌驱动行业发展的威权。&lt;/p&gt;

&lt;p&gt;曾经一位领导说我们的软件系统发展应该先是“能用”，再是“好用”，最后是“易用”。这其实也是软件系统从功能为主朝用户至上，体验为王方向发展。套用阿里一句词：“让天下没有难用的软件”。&lt;/p&gt;

&lt;p&gt;那如何能做到“体验为王”的软件设计呢？&lt;/p&gt;

&lt;p&gt;作名一名架构师，首先要始终以用户和角色为中心，要从原有的我能为你提供什么功能，转变成用户最需要什么为出发点。首先要把自己当成用户，如果连自己都不去使用自己设计的系统，又如何把系统设计好呢。&lt;/p&gt;

&lt;p&gt;有人说，软件架构设计不是UI/UE设计，架构设计是功能逻辑设计，是技术实现设计，是物理部署设计；而用户体验只是UI/UE都需要考虑的。UI设计，确切地说，用户使用界面上设计首先要考虑用户体验。但体验不仅仅是界面上的交互操作的易用性，心理感受等。试想，如果你浏览一个网页或使用一个App，虽UI设计非常符合用户的使用习惯，但响应速度却非常地慢。这也不会是好的体验。速度上需要零等待，存储上需要大容量，并发上需要高吞量。这些都需要在软件系统架构上着重设计。&lt;/p&gt;

&lt;p&gt;软件架构设计要以需求的场景化、实例化驱动设计。无法场景化的需求往往是伪需求。真正的需求是满足目标用户在特定场景下的目标。作为架构设计师，要弄清其中两个关键因素：1）目标用户；2）特定场景下的目标。&lt;/p&gt;

&lt;h2 id=&#34;平台为本&#34;&gt;平台为本&lt;/h2&gt;

&lt;p&gt;平台化分为技术支撑型平台和应用实现型平台。技术支撑型平台的用户为软件开发人员，提供者负责平台的维护和升级，用户负责基于平台的上层实现。这类平台包括软件中间件、开发工具、应用服务器等。应用实现型平台的用户为终端用户，提供者不但负责平台的维护和升级，还要负责实现基于平台的上层应用。&lt;/p&gt;

&lt;p&gt;平台化首先需要在架构设计上考虑系统的开放性，通常的做法是系统功能服务化，API化。采用标准的通信协议，让系统易于被集成。系统具备更好的应用开发和维护的工具和接口，实施时可以迅速根据用户的特点进行部署和二次开发，用户可以最大限度地使用贴近自身特点来重新定义软件功能。&lt;/p&gt;

&lt;p&gt;像Saleforce等SaaS平台一样，平台化使运行于上层的应用软件在某种程度上做到与技术无关，而是面向具体业务，提供更为领域化的DSL。平台化提供各种易于组装的套件，可定制修改的业务模板。这样才能面向合作伙伴，构建平台之上的工具链，生态社区等。&lt;/p&gt;

&lt;p&gt;软件系统在研发和使用过程中需求变更不可避免。平台化的软件也在架构设计上，需地支持系统的平滑演进与对外接口兼容。这也需要在设计上考虑平台与上层业务之间的边界划分。上层的业务是最为变更频繁的，一是业务领域特性一般的变更不要侵入到平台。其二、平台的发展也不能影响上层业务的运行。当系统面对市场需要时，要评估这些需求是否需要在平台增加或改动哪些功能，平台软件是要随着客户需求而发展演进的。只有不断切合上层业务发展诉求的平台才具有更久的生命力。&lt;/p&gt;

&lt;h2 id=&#34;内生敏捷&#34;&gt;内生敏捷&lt;/h2&gt;

&lt;p&gt;业务逻辑复杂多变，如何保证程序逻辑的代码稳定是架构师需要解决的问题，良好的模块划分和扩展性强的接口设计都是解决这个问题的利器。微服务化，大系统小做。系统分解的目标并不仅仅是搞出一堆很小的服务，这不是目标；真正的目标是解决系统在业务急剧增长时遇到的问题。&lt;/p&gt;

&lt;p&gt;模块化，微服务化的让某一个功能足够内聚，足够小，代码容易理解、开发效率提高。服务之间可以独立部署，微服务架构让持续集成（CI），持续部署（CD）成为可能，基于数据化地构建软件生产流水线成为可能。各个服务之间可以在流水线上按功特性灵活组装。&lt;/p&gt;

&lt;p&gt;软件的本质是要面对各种业务需求的变化，这需要系统高度地抽象化，以不变来应对万变。使用一切可以减少编码的技术，例如元数据驱动。软件系统设计已经发展到使用运行时引擎从元数据（即关于应用程序本身的数据）生成应用程序组件的阶段。在一个定义良好的元数据驱动的体系结构中，已编译的运行时引擎（内核）、应用数据、描述一个应用程序的基础功能的元数据，以及与每个租户的数据和定制相关的元数据之间有一个明确的分离。这些明显的边界使人们有可能独立更新系统内核，修改的核心应用程序，或定制租户的具体组成部分，虚拟意义上来说，几乎不会影响其他人。&lt;/p&gt;

&lt;h2 id=&#34;数据驱动&#34;&gt;数据驱动&lt;/h2&gt;

&lt;p&gt;数据驱动是系统内生的数据感知，基于系统运行数据进行系统的预测与资源优化。数据驱动的终极目标是希望利用数据能够直接在生产环境带来改变，提供价值。&lt;/p&gt;

&lt;p&gt;数据驱动自动化干预，需要不断优化的分析算法，利用数据基础在特定领域完成基于算法的自动调整。算法线上部署除了对平台和算法本身的支持之外，还需要考虑：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数据的及时性：实时数据和历史数据的组合，在特定周期下替换历史数据。&lt;/li&gt;
&lt;li&gt;异常数据的容忍：线上算法的输入无法做到离线的清洗水平，需要更健壮的数据预处理模块。&lt;/li&gt;
&lt;li&gt;算法的迭代：需要可靠的离线迭代平台来纠正线上算法运行过程中的误差和偏离。采集线上的数据到离线平台，通过离线平台调整参数和适应性。支持从离线平台推送新的算法。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个系统的开放性，也体现在数据的开放性。系统架构上需考虑可被高层的系统，更深度的分析。不同维度与不同层次的分析，才能让数据变得更有价值。&lt;/p&gt;

&lt;h2 id=&#34;原生云化&#34;&gt;原生云化&lt;/h2&gt;

&lt;p&gt;原生云化指“Cloud Native”，它是多种不同思想的一个集合，这些思想帮助软件系统转移到云平台。这些思想包括DevOps、持续交付、微服务、敏捷基础设施、康威定律等。“Cloud Native”没有标准的官方定义，但包括如下几个特征：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可移植：应用层与物理层隔离。应用从开发环境迁移到物理环境无需改变环境配置。&lt;/li&gt;
&lt;li&gt;自动化：通过持续集成和自我修复系统将IT基础设施的开发和部署进行自动化。&lt;/li&gt;
&lt;li&gt;效率提升：通过引入全新方式来降低运维成本，让系统管理员可以有更多时间去改进系统，而不是把时间都用在维护系统上。&lt;/li&gt;
&lt;li&gt;意识改变：DevOps的兴起以及运维和开发人员越来越多的共同协作发布服务，包括微服务和传统服务，让用户意识到服务发布的速度和敏捷性，已经和稳定性一样重要。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;原生云化的系统也是具有&lt;a href=&#34;https://12factor.net/&#34;&gt;12因子&lt;/a&gt;。原生云化首先考虑是的分布式一切。分布式架构可以以水平扩展，通过横向扩充节点，如一个节点扩充到多个节点，每个节点运行独立实例，节点与节点之间通过网络互连，随着节点扩充系统处理能力能够随之提升，单节点失效时，整个集群仍然可以对外提供服务。遵循12因子原则的应用程序，具有一致的架构接口。为了使创建的分布式应用马上就可以部署在云中，这些接口的构建采用一种无状态、面向进程的设计模式。&lt;/p&gt;

&lt;p&gt;多租户也是云计算的基本属性之一，原生云化的系统也必定是多租户架构的系统。利用多租户带来资源上高度共享模式，提高资源资源利用率，降低单位资源成本。但是共享资源越多，会带来租户的隔离性难度越大，成本越高。在按隔离程序不同层次，可分为物理多租架构与逻辑多租架构，物理多租架构技术如采用虚拟化技术，Docker容器，以及应用容器技术来隔离租户资源。逻辑多租架构技术如应用程序进程间隔离，数据切割隔离。&lt;/p&gt;

&lt;p&gt;原生云化的系统也是最大程度自动化。健壮自动化几乎能处理传统IT中需要手工处理的所有事情：当应用实例增减时更新路由器和负载均衡组件，部署应用所需的供应和联网服务，分配新的基础设施，设置监控和灾后恢复服务，日志聚合，当基础设施失效时重新部署应用。这些高级自动化实践，能把你从应对零日危险的痛苦中拯救出来：自动化采用滚动更新的方式，为每一个节点打上安全补丁，同时又保证服务一直在线。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>软件架构一些感想</title>
      <link>http://lanlingzi.cn/post/thoughts/2016/0319_arch_diathesis/</link>
      <pubDate>Sat, 19 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/thoughts/2016/0319_arch_diathesis/</guid>
      <description>&lt;h2 id=&#34;软件架构&#34;&gt;软件架构&lt;/h2&gt;

&lt;p&gt;软件系统架构不只是软件本身架构，它是一个全系统、全网络的架构，从层次上由低到高分为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;程序架构&lt;/li&gt;
&lt;li&gt;系统架构&lt;/li&gt;
&lt;li&gt;产品架构&lt;/li&gt;
&lt;li&gt;生态、商业模式的架构&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;任何一个架构师，都是需要重点解决某方面的尖锐问题，同时避免在不合适的场景下，一种技术、一类框架或一种架构模式被滥用。架构就需要对整体框定好范围与约束。&lt;/p&gt;

&lt;p&gt;架构设计不可能面面俱到，要解决或是发挥关键路径上的资源合理有效的最大价值。一个好的架构，不会随着时间或业务的变换，而需要进行大的破坏性的变化。
&lt;/p&gt;

&lt;h2 id=&#34;架构演进&#34;&gt;架构演进&lt;/h2&gt;

&lt;p&gt;从互联网公司的角度来看，他们认为架构都是在实际应用过程中的生长，一开始就设计和实施面面俱到的架构是不符合互联网快速交付的方式的，不要过度设计，谁也不知道业务上线后业务量将会是一个什么量。&lt;/p&gt;

&lt;p&gt;架构的演进过程基本是围绕着性能，可靠性，扩展性，安全性，容灾展开。而对于可靠性，他们认为故障是不可能避免的，失败可能是常态，核心是如何地减少故障对用户或系统产生的影响范围。要提供有损服务，在故障的情况下，保证核心服务，可能放弃一些其它的服务。&lt;/p&gt;

&lt;p&gt;相对于电信业务，互联网公司的业务更侧重于用户体验，极致的响应速度与简单易用的体验是第一个设计原则。而电信业务传统是更侧重于可靠性，甚至零无损。&lt;/p&gt;

&lt;h2 id=&#34;架构师素质&#34;&gt;架构师素质&lt;/h2&gt;

&lt;p&gt;架构师要能充分理解用户需要，充分协调和利用资源，满足需求； 具备基本的方法论，敏锐的观察力，善于对事物的抽象，提炼，简化。同时由于架构涉及到范围广，需要能快速学习新知识，善于学习关键点，不能由于过多限于细节而影响精力分配。&lt;/p&gt;

&lt;p&gt;架构师很多时间是技术决策，需要能勇于应对变化，积极改变，敢于挑战。能够将方案落地，从解决系统的具体问题出发，能解决别人看不清的问题，也同时需要具有战略眼光，看得更远。&lt;/p&gt;

&lt;p&gt;架构是上层建筑，影响深远，所以架构师需要善于识别和消除高风险，要广泛地吸收不同的意见，头脑风暴，风险识别、评估。对于风险进行排序，对于高风险点进行原型验证，切不可纯理论的架构，做成空中楼阁。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>软件设计原则</title>
      <link>http://lanlingzi.cn/post/technical/2016/0306_arch_principle/</link>
      <pubDate>Sun, 06 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2016/0306_arch_principle/</guid>
      <description>&lt;p&gt;软件也像人一样，具有生命力，从出生到死亡，会经历多种变化。软件架构设计也不是一蹴而就的，是不断地演进发展。但为了能较好的发展，在软件设计时需要考虑一些原则。&lt;/p&gt;

&lt;h3 id=&#34;清晰原则-使用简洁接口-简单部件组合&#34;&gt;清晰原则：使用简洁接口，简单部件组合&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;编程的本质就是要控制复杂度，后期维护会占用大部分的时间。&lt;/li&gt;
&lt;li&gt;降低整体复杂度，用清晰的接口把若干简单模块组合成一个复杂的系统。&lt;/li&gt;
&lt;li&gt;对外隐藏细节，“不要与陌生人说话”。&lt;/li&gt;
&lt;li&gt;多数问题局限天一个局部，不要影响到全局。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结：本质是分而治之，复杂问题简单化，抽象框架，有序组全。
&lt;/p&gt;

&lt;h3 id=&#34;清晰原则-清晰胜于机巧&#34;&gt;清晰原则：清晰胜于机巧&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;代码直白易懂，代码是给人看的，不是给机器看的。&lt;/li&gt;
&lt;li&gt;维护代码的人，其中也你包括你自己，善待代码，就是善待自己。&lt;/li&gt;
&lt;li&gt;不要了一点性能提升而引入复杂的算法，不要为了炫耀技能而编写晦涩难懂的代码。&lt;/li&gt;
&lt;li&gt;复杂晦涩的代码是Bugs的温床，高昂的维护成本将抵消可怜的性能提升。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结：代码简洁晚懂，谨慎引入复杂度。&lt;/p&gt;

&lt;h3 id=&#34;简洁原则-设计简洁-降低复杂&#34;&gt;简洁原则：设计简洁，降低复杂&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;复杂问题简单化是一个设计者的能力体现，避免不必要的使用问题复杂化的因素。&lt;/li&gt;
&lt;li&gt;在市场导向下，在不良的架构上很容易堆砌花哨无用的新特性，导致软件趋于复杂。&lt;/li&gt;
&lt;li&gt;在进度压力下，不会做出各种折中的个性与不和谐的新特性开发。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结：过滤排序需求，追求稳定简洁。&lt;/p&gt;

&lt;h3 id=&#34;组合原则-组合-接拼-编排&#34;&gt;组合原则：组合，接拼，编排&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;把复杂问题分解为一条程序处理链条。&lt;/li&gt;
&lt;li&gt;程序之间可以通信，前者的输出是后者输入。&lt;/li&gt;
&lt;li&gt;通信方式尽量采用简单协议，并且与语言无关。&lt;/li&gt;
&lt;li&gt;组合程序之间无内部状态依赖，互相独立，处理链上下游不做假设，可替换。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结：面向微服务的设计。&lt;/p&gt;

&lt;h3 id=&#34;透明原则-设计与实现分离可见&#34;&gt;透明原则：设计与实现分离可见&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;设计简单，包括流程、数据结构、接口，在代码级别容易理解。&lt;/li&gt;
&lt;li&gt;支行时刻可通过输出信息或者接口查询运行状态，可控制程序是否正确运行。&lt;/li&gt;
&lt;li&gt;执行调试链、健康状态可跟踪、可分析。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结：简单设计，简明实现，状态监控。&lt;/p&gt;

&lt;h3 id=&#34;吝啬原则-除非别无它法-不要编写庞大的程序&#34;&gt;吝啬原则：除非别无它法，不要编写庞大的程序&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;程序庞大包括两个方面：程序体积大与程序复杂而维护困难。&lt;/li&gt;
&lt;li&gt;模块和函数尺寸都有一个上限，比如单模板代码10K，单函数100L。&lt;/li&gt;
&lt;li&gt;导致程序庞大的因素：先天设计不良，后天维护增加新特性。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结：合理设计，考虑扩展性，对庞大保护警惕。&lt;/p&gt;

&lt;h3 id=&#34;吝啬原则-有的放矢-按需分配资源&#34;&gt;吝啬原则：有的放矢，按需分配资源&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;若可能，当一个事情发生时候再分配资源，而不是预先分配，初始化时静态分配最小资源，随着业务动态增加资源分配。&lt;/li&gt;
&lt;li&gt;异步消息环境下，消息通信带来上下文切换，代价高昂。&lt;/li&gt;
&lt;li&gt;必要时对消息数据合并，打包发送，减少对网络资源的消耗。&lt;/li&gt;
&lt;li&gt;业务处理与消息发送分离，数据组织独立，统一打包发送。&lt;/li&gt;
&lt;li&gt;控制并发实例的数据，分批处理，防止下游过载各实例之间的恶性竞争通信资源。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结：按需分配资源，珍惜消息通信机会。控制并发，避免消息突发。&lt;/p&gt;

&lt;h3 id=&#34;健壮原则-健壮源于透明与简洁&#34;&gt;健壮原则：健壮源于透明与简洁&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;软件在超过设计者设想的意外场景下也能够运行良好。&lt;/li&gt;
&lt;li&gt;Bugs是一种异常，复杂性和特殊处理都是Bugs的温床。&lt;/li&gt;
&lt;li&gt;逻辑透明，接口简单有助于减少Bugs，即使出现Bugs也容易排除。&lt;/li&gt;
&lt;li&gt;软件设计时要考虑异常输入，边界条件，和过载场景。&lt;/li&gt;
&lt;li&gt;软件模块之间要处理流程上考虑能务匹配，流控，过载保护。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结：简单透明，处理能力匹配；考虑异常场景，提升健壮性；匹配上下游处理能力，闭环控制为主，开环控制为辅。&lt;/p&gt;

&lt;h3 id=&#34;表示原则-把知识叠入数据-简化统一处理逻辑&#34;&gt;表示原则：把知识叠入数据，简化统一处理逻辑&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;数据抽象建模，使用数据之间的关联关系来体现业务逻辑，或者领域知识，使得业务处理逻辑代码简单一致稳定。&lt;/li&gt;
&lt;li&gt;可通过修改数据模型可以支持新业务，逻辑处理代码不用修改。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结：领域模型驱动设计，数据数据提练来描述业务本质。&lt;/p&gt;

&lt;h3 id=&#34;缄默原则-只输出有用的信息&#34;&gt;缄默原则：只输出有用的信息&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;保持沉默，良好的行为是默默地工作，决不唠唠叨叨，碍手碍脚，程序也是如此。&lt;/li&gt;
&lt;li&gt;输出大量无用的信息会耗费资源，淹没重要信息，干扰维护人员定位问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结：沉默是金，惜时亦如金。输出的信息是必要的，有用的，不重复的。&lt;/p&gt;

&lt;h3 id=&#34;补救原则-异常时候-干净退出-输出详细信息&#34;&gt;补救原则：异常时候，干净退出，输出详细信息&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;当程序出现异常时，输出必要信息，使用简单方法结束。&lt;/li&gt;
&lt;li&gt;宽容地接受，严格地发送，提升程序的容错能力。&lt;/li&gt;
&lt;li&gt;程序要么正确执行，要么响亮倒塌。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结：看待这个问题一分为二，选择异常恢复方法要保证对用户的业务逻辑影响最小为基本原则。因此并不是说所有的异常都是进程退出重启，有时可以告警，事件通知，让管理员来处理，给出明确的修复方案说明。&lt;/p&gt;

&lt;h3 id=&#34;经济原则-宁花机器一分钟-不花程序员一秒&#34;&gt;经济原则：宁花机器一分钟，不花程序员一秒&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;对于一个问题，选择算法的时候宁愿选择一个简单，但可能是效率低一些的算法，也不要选择一个性能好但复杂度很高的算法。&lt;/li&gt;
&lt;li&gt;硬件的进步来弥补性能的下降，换来的是程序简单可靠，维护成本低。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结：辩证地看问题，选择简单，把复杂留给机器，解放程序员。&lt;/p&gt;

&lt;h3 id=&#34;生成原则-避免手工hack-让程序去生成代码&#34;&gt;生成原则：避免手工Hack，让程序去生成代码&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;人最不适合干大量重复细致的工作，或多或少都会出错，因此导致Bugs。&lt;/li&gt;
&lt;li&gt;与此相反，计算机最适合干规则明确，重复枯燥的工作，而且不会出错。&lt;/li&gt;
&lt;li&gt;对于一个规则明确的工作，一种可行的办法就是编写一个我程序，根据输入规则生成代码，让生成的代码去解决问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结：分析规则，能按照规则生成代码，可检查发现问题。&lt;/p&gt;

&lt;h3 id=&#34;优化原则-雕琢前先有原型-跑之前先学会走&#34;&gt;优化原则：雕琢前先有原型，跑之前先学会走&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;90%的功能能够实现，比100%功能永远不能实现要好得多。&lt;/li&gt;
&lt;li&gt;先求可行，再求正确，最后求快。&lt;/li&gt;
&lt;li&gt;原型可能有效地解决关键技术，保证系统是可以实现的。&lt;/li&gt;
&lt;li&gt;让客户看到可以执行的原型，对需求的理解更为准确，防止做无用功。&lt;/li&gt;
&lt;li&gt;过早优化是万恶之源，过早地优化会破坏程序结构，代码与数据结构杂乱无章；过早优化不清晰系统瓶颈，局部优化破坏整体优化。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结：性能是设计出来，不是优化来出来。&lt;/p&gt;

&lt;h3 id=&#34;多样原则-拒绝封闭和唯一&#34;&gt;多样原则：拒绝封闭和唯一&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;系统开放，只有开放，才能进步，才能得到最为广泛的验证。&lt;/li&gt;
&lt;li&gt;开放，可扩展，用户可定制，符合实际需求和获到高可靠性。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结：系统开发，留给用户定制空间，毕竟需求具体多样性，我们不能穷尽，最终只有用户才能准确理解自己的需求。&lt;/p&gt;

&lt;h3 id=&#34;同源原则-避免重复-数据同源&#34;&gt;同源原则：避免重复，数据同源&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;重复的代码不仅仅是浪费，也是Bugs的滋生之地。&lt;/li&gt;
&lt;li&gt;出现大段代码重复，说明开发者缺少对代码控制与抽象提炼能务，优秀的工程轻易不会在进度压力下让步。&lt;/li&gt;
&lt;li&gt;数据重复危害更大，一则浪费存储空间，二则容易出现不一致。&lt;/li&gt;
&lt;li&gt;在性能允许的情况下，尽量共享数据或者按需订阅，避免全量订阅。&lt;/li&gt;
&lt;li&gt;如果上述条件不具备，那么采用数据同源技术和一致性校验来保证数据的一致性。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结：拒绝重复，必须重复的时候考虑通过工具同源和一致性校验。&lt;/p&gt;

&lt;h3 id=&#34;扩展原则-设计时着眼未来-未来总比想象来得快&#34;&gt;扩展原则：设计时着眼未来，未来总比想象来得快&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;对于一个一次性的程序来讲，架构和设计只会带来成本上升，复杂度提高，与性能的下降。&lt;/li&gt;
&lt;li&gt;当开发一个支持多种产品的软件平台，其生命周期可能是十年以上。用户的需求是不断地变化，硬件环境也是不断地变化。&lt;/li&gt;
&lt;li&gt;只有适应变化，不能拒绝变化，可扩展性是软件非功能属性中，在大部分情况下排在可靠性，高性能之前&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结：不对外界进行假设，这些假设在时间面前都是脆弱的。&lt;/p&gt;

&lt;h3 id=&#34;扩展原则-给雪球寻找一个核心&#34;&gt;扩展原则：给雪球寻找一个核心&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;雪球都有一个内核，尽管可能是一粒不起眼的小石头。&lt;/li&gt;
&lt;li&gt;常说软件要内聚，内聚需要核心。&lt;/li&gt;
&lt;li&gt;微内核，插件化机制。框架即核心，框架之上定制好插件，构建系统。&lt;/li&gt;
&lt;li&gt;从问题知识域发现稳定部分进行抽象提升，成为系统的框架。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结：从框架的角度来看系统，框架之间的有机组合构建系统，系统的演化就是在框架稳定情况下增加替换相关的插件。&lt;/p&gt;

&lt;h3 id=&#34;扩展原则-扩展就是少修改&#34;&gt;扩展原则：扩展就是少修改&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;软件可扩展性是有前提和应用场景的，不存在可以随意扩展的软件。&lt;/li&gt;
&lt;li&gt;增加新功能做到不修改既有软件，代码无需修改，通过修改数据模型或者重新配置获得新特性。&lt;/li&gt;
&lt;li&gt;修改集中在新增加的软件之上，也就是说在增加新特性时，对老代码封闭，对新代码新特性开放。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结：系统开闭原则，修改对系统稳定不构成影响。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>软件架构设计</title>
      <link>http://lanlingzi.cn/post/notes/2016/0215_about_soft_arch/</link>
      <pubDate>Mon, 15 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/notes/2016/0215_about_soft_arch/</guid>
      <description>&lt;h2 id=&#34;什么是软件架构设计&#34;&gt;什么是软件架构设计&lt;/h2&gt;

&lt;p&gt;依稀记得公司的软件架构培训材料中说到软件架构=组件+交互。最近读温昱的&lt;a href=&#34;http://baike.baidu.com/link?url=FwG7S8RSOkY8BzeZ1MBRSppAkJsTZZZTHRlj8wjvq7r4BPowUlimOuVUyZusyrUvaYXurh8hqxF3O0FTxA-8c_&#34;&gt;《软件架构设计》&lt;/a&gt;才知道这只是其中一大阵营的观点。而软件架构在定义上分为&lt;code&gt;“组成派”&lt;/code&gt;和&lt;code&gt;“决策派”&lt;/code&gt;两大阵营。“组成派”认为软件架构是将系统描述成计算组件及组件之间的交互；而“决策派”认为软件架构包含了一系列的决策。事实上，从我司实际操作来看，两种观点并不是互斥的，而是相辅相成。两种观点只是站在不同的角度来看待软件架构。架构师在分割组件模块时，选择备选方案时，也是会不得不去作出各种决策，架构没有最完美的，只有在特定场景需求下最合适的。
&lt;/p&gt;

&lt;p&gt;“组成派”的两个明显的特点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;关注架构实践的客体——软件，以软件本身作为描述对象。&lt;/li&gt;
&lt;li&gt;分析了软件的组成，说明软件不是一个‘原子’意义上的整体，而是有不同的部分经过特定的接口进行连接组成的一个整体，这对软件开发来说很重要。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;“决策派”的两个明显的特点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;关注软件架构中的实体——人，以人的决策为描述对象。&lt;/li&gt;
&lt;li&gt;归纳了软件架构决策的类型，指出架构决策不仅包括关于软件系统的组织、元素、子系统和架构风格等几类决策，还包括关于众多非功能性需求的决策。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;按照“组成派”的观点，软件架构关注的是软件整体的分割和交互，之所以分割，是因为不同的部分在逻辑或物理上相对独立，通过“分而治之”的原则进行分割可以更好的理解整个系统，把握用户的需求，但是虽然整个软件可以分割成多个模块或子系统，但是模块和子系统之间的通信和交互也是很重要的。按照这种观点，架构师的主要任务是将软件分割成不同的模块，并定义模块之间的接口。&lt;/p&gt;

&lt;p&gt;按照“决策派”的观点，软件是一个在很多限制下产生的产品，这些限制包括用户和技术两方面，用户方面包括功能需求、性能需求、硬件需求等，技术方面包括技术选择、可扩展性、可重用性、可维护性等。按照这中观点，架构师的主要任务就是作出上述个各种限制作出选择或决策，是一系列的有层次的决策。&lt;/p&gt;

&lt;h2 id=&#34;软件架构设计的质量属性&#34;&gt;软件架构设计的质量属性&lt;/h2&gt;

&lt;p&gt;按照“决策派”的观点，软件架构并不仅仅关注软件本身的结构和行为，还注重其他特性：使用、功能性、性能、弹性、重用、可理解、经济以及技术的限制和权衡等。&lt;/p&gt;

&lt;p&gt;软件架构设计中需要考虑软件的质量属性，也是上述所说需要权衡与决策的。质量属性可归类为三类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;软件系统本身的质量属性：可用性，可维护性，高性能，安全性，可测试性，易用性。&lt;/li&gt;
&lt;li&gt;软件系统的商用属性：上市时间，成本与收益，目标市场，生命周期，系统生态。&lt;/li&gt;
&lt;li&gt;架构本身的质量属性：概念完整性，正确性，可理解性，可构建性。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如何描述质量属性需求呢？一般采用质量属性场景作为一种规范。 质量属性场景是一种面向特定的质量属性的需求。它由六部分组成：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;刺激源：这是某个生成该刺激的实体（人、计算机系统或者任何其他刺激器）。&lt;/li&gt;
&lt;li&gt;刺激：该刺激是当刺激到达系统时需要考虑的条件。&lt;/li&gt;
&lt;li&gt;环境：该刺激在某些条件内发生。当刺激发生时，系统可能处于过载，或者运行，也可能是其他情况。&lt;/li&gt;
&lt;li&gt;制品：某个制品被刺激。这可能是整个系统，也可能是系统的一部分。&lt;/li&gt;
&lt;li&gt;响应：该响应是在刺激到达后所采取的行动。&lt;/li&gt;
&lt;li&gt;响应度量：当响应发生时，应当能够以某种方式对其进行度量，以对需求进行测试。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;软件架构设计的原则&#34;&gt;软件架构设计的原则&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;全面解耦合原则：对业务进行抽象建模，业务数据与业务逻辑解耦，软件件与硬件解耦，平台与产品解耦，系统各部件之间解耦。&lt;/li&gt;
&lt;li&gt;服务化、组件化原则：以服务，数据为中心，构建服务化，组件化的架构，具备灵活，按需组合的能力。&lt;/li&gt;
&lt;li&gt;隔离与自治原则：通过接口隐藏服务、组件的实现细节，服务与组件之间只能基于接口交互，接口契约化、标准化。跨版本兼容；服务、组件可独立发展，独立发布，独立升级。服务自治，可视，可管，可控，可测，可维，故障自愈。&lt;/li&gt;
&lt;li&gt;弹性伸缩原则：构建全分布式云化架构，或借鉴云化架构思想，每个服务具备横向扩展能务，支持按需使用、自动弹性伸缩，可动态替换，灵活部署，支持高性能、高吞吐量、高并发，高可用业务场景。&lt;/li&gt;
&lt;li&gt;安全可靠原则：构建最小的权限、纵深防御、最小公共化、权限分享、不轻信、开放设计、完全仲裁、失效安全、保护薄弱环节、安全机制经济性、用户接受度以及加强隐私保护的安全体系，确保系统、网络、数据的机密性，完整性、可用性、可追溯。业务系统零故障为导向，按需构建分层分级的可靠性，通过故障的预测、预防、快速恢复，避免故障的发生。&lt;/li&gt;
&lt;li&gt;高效开发原则：创建支持迭代、增量、持续交付的架构，支持部件可独立开发，自动化编译构建、测试、集成验证，并易于高效修改与持续优化；支持开发组织小型化、扁平化，支持小团队独立高效并行开发。&lt;/li&gt;
&lt;li&gt;持续演进原则：架构并非一蹴而就，需要有效地管理架构需求，持续构建和发展架构，适应业务需求变化，适时引入业界最佳实践，及时重构，确保架构生命力和竞争力。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;参考材料：&lt;br /&gt;
* 温昱的《软件架构设计》&lt;br /&gt;
* 软件体系结构的质量属性&lt;br /&gt;
* 华为产品架构设计原则&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>参加ArchSummit北京站感受</title>
      <link>http://lanlingzi.cn/post/technical/2015/1227_bj_archsummit/</link>
      <pubDate>Sun, 27 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2015/1227_bj_archsummit/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://q.infoqstatic.com/ASSZ2015/LOGO/AS-LOGO358x146.png&#34; alt=&#34;ArchSummit&#34; /&gt;&lt;/p&gt;

&lt;p&gt;参加ArchSummit北京站已有一周时间，一直没有时间来梳理一下。整体来说，这次的北京之行，不是很满意，可能是这类会议听多的原因，感觉ArchSummit的质量是越来越差了，没有什么新鲜感，觉得不值那6K的价格。&lt;/p&gt;

&lt;h2 id=&#34;组织不足&#34;&gt;组织不足&lt;/h2&gt;

&lt;p&gt;12月份的北京已是非常的干冷，可能由于我在南方呆久了，一到北京是极其地不适应，在北京三天多的时间，嘴唇开裂，到现在还没有完全好干净。离开北京的那一天，正好又感受了一下北京正宗的霾，帝都的人们活得真不容易啊。
&lt;/p&gt;

&lt;p&gt;为什么说ArchSummit组织不足呢？InfoQ也算是组织过多次大型会议的公司，但这一次比我之前参加InfoQ组织的任何会议都差，更无法与阿里组织的云栖会议相比。一个是以组织会议赚钱，一个是以个会议来打造生态。这次的ArchSummit是在北京国际个会议中心举行，每个分会场我都差不多的参加过，明显感觉组织不足:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;每个分会场演讲时，大门紧闭，空间质量非常的差，又没有充足的通风设备，感觉非常的窒息。&lt;/li&gt;
&lt;li&gt;工作人员能力不行，第一天下午，有几个分会议室由于投影没有准备好，拖时半个多小时，也不见中途主持人来了说一声，最后连声道歉都没有。&lt;/li&gt;
&lt;li&gt;几个分会场的投影效果差，灰蒙蒙的看不清楚。&lt;/li&gt;
&lt;li&gt;连个矿泉水瓶上都是广告，并且不是每个位置都摆放好水，而是需要自己去指定位置去拿。有的分会场甚于连矿泉水都没有见到，准备的份数太少，6K的价格连个水都喝不到。&lt;/li&gt;
&lt;li&gt;就餐地方太小（又是自助餐），效率低下，大量的人员挤在走廊上，我是差不多等了30多分钟才能进餐厅吃饭。大量的人员挤在一起存在安全风险。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;两天的ArchSummit大会日程比较紧凑，再加上大多数时候有六个专题在并行，因此每个人能够真正去听的课程不会太多。我们也是只能选择地去听，但是每个演讲介绍不足，有些演讲名字高大上，听了之后，感觉有点上当，部分讲师存在水分，这里就不直说了。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;不过，参加ArchSummit大会，还是听到一些业内公司的技术分享，尤其是互联网企业，在应用新技术方面还是比较超前的。相对我们电信行业来说，我们遇到的问题有些是相似的，甚至部分问题的解决办法也与我们曾经想过的一些方案类似，只是他们早已经落地并且做到极致了。有很多东西对我们值得参考，可以说从开源使用、技术形态，运作方式，远远走在我们的前面了。&lt;/p&gt;

&lt;h2 id=&#34;paas平台&#34;&gt;PaaS平台&lt;/h2&gt;

&lt;p&gt;目前稍具规模的互联网公司，都会自建数据中心。而互联网的业务又有如下特点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;业务需要快速上线，唯快不破&lt;/li&gt;
&lt;li&gt;业务形态众多，迭代周期快&lt;/li&gt;
&lt;li&gt;数据处理量大，海量请求和高并发的挑战&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;支撑业务的发布，上线，运维，都需要对业务应用的全生命周期管理，各个公司都有一套平台，他们或多或少都能称得上内部的PaaS平台。而PaaS平台核心：&lt;/p&gt;

&lt;h3 id=&#34;分布式框架&#34;&gt;分布式框架&lt;/h3&gt;

&lt;p&gt;首先是《蚂蚁金服金融级PaaS平台构建之道》分享，阿里在国内技术一直算是走到前列。这次带来的演讲，蚂蚁金服的分布式服务注册中心（DSR），与阿里其它系的Dubbo，HSF都差不多。他们的目标都要解决应用服务化后，服务注册发现问题，可以说是未来PaaS平台中，服务注册发现将成来PaaS的核心中的核心。&lt;/p&gt;

&lt;p&gt;后一场听了《主流容器SDN技术与微服务架构实践》，来自七牛的分享。虽然演讲的内容是容器的SDN技术（算不上大范围的SDN），也同时点到微服务架构。虽然他们所讲的容器方案都说是自研的，但整体上感觉与K8S的设计是相似，甚至像Pod之类的概念来也是借鉴来的。在容器环境下的同时也要解决分布式的服务发现问题，他们采用是DNS机制。服务路由上支持L4与L7的负载均衡，对业务无侵入。基于安全组的服务Discovery，虽然没听太明白，感觉跟K8S的Proxy机制是差不多的。&lt;/p&gt;

&lt;h3 id=&#34;中间件服务&#34;&gt;中间件服务&lt;/h3&gt;

&lt;p&gt;在《蚂蚁金服金融级PaaS平台构建之道》中初步介绍了分布式消息(DMS)、分布式数据源（DDS），分布式事务（DTS）的一些使用场景与技术特点。在云环境下，中间件服务必不可少，让业务应用只关注自己的业务逻辑。中间件服务要面对的是一个复杂、不断变化的计算环境。抽象出业务的公共能力服务化。使用中间件服务，可以简化业务应用在一些通用技术的成本，如数据一致性，安全控制，高性能，可靠性等。而中间件技术正在呈现出业务化、服务化、一体化的趋势发展。高可用性，自管理性，业务适应性是当前中间件服务面临的挑战。&lt;/p&gt;

&lt;h3 id=&#34;弹性扩展&#34;&gt;弹性扩展&lt;/h3&gt;

&lt;p&gt;在云计算中，引入虚拟化技术，采用弹性伸缩是老生常谈了，一键式按需弹性，基于性能采集的自动弹性。听了《微众银行基于自主可控技术的分布式架构实践》，给我对弹性带了新的思考。互联网+的应用是：海量用户，海量交易，海量数据。这要求对系统在架构设计上充分考虑容量的扩展性，性能的扩展性。&lt;/p&gt;

&lt;p&gt;微众的架构特点是分布式松耦合架构+一主两从节点强制同步的架构。在分布式松耦合架构是按客户群来水平分割，一个节点上涵盖多个客户业务。分布式多节点是分散风险，如果有节点受损，也是部分客户有影响。而每个节点上又采用一主两从节点强制同步，来提高整个系统的冗余。整个系统以客户为单元可控分布，将客户量、交易频繁度与系统负载之间的关系解耦。随着客户量增加或客户交易频繁度的增加,系统负载也会随着增加：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;横向扩展(Scale Out)解决用户量增加&lt;/li&gt;
&lt;li&gt;纵向扩展(Scale Up)解决交易频繁度增加&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;并且严格要求，横向扩展只能解决用户量问题，不能通过纵向扩展来解决用户量问题，反之亦然。&lt;/p&gt;

&lt;h3 id=&#34;容灾备份&#34;&gt;容灾备份&lt;/h3&gt;

&lt;p&gt;云计算环境下，容灾备份也是需要重点考虑的，容灾设计强调的是系统对外界环境影响具备快速响应能力，尤其是当发生灾难性事件并对IDC节点产生影响时，能够具备节点级别的快速恢复能力，保障系统的持续可用。像微众介绍IDC2.0中提到的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数据库三中心集群化部署&lt;/li&gt;
&lt;li&gt;三数据副本强同步&lt;/li&gt;
&lt;li&gt;应用多中心多活部署&lt;/li&gt;
&lt;li&gt;应用多中心多实例多活部署&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;蚂蚁金服金服提到的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;两地三中心&lt;/li&gt;
&lt;li&gt;异地多活&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;支付宝有一个专题《支付宝的高可用与容灾架构演进》，我觉得有意思的是其中的单元化与容灾。单元化应该是微服务化中一种具体运用吧。什么是支付宝的单元化：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;核心业务,核心剥离：数据按照UserID拆分,多机房部署,调用封闭,部分数据,不共享&lt;/li&gt;
&lt;li&gt;非核心业务,长尾独立：不能按照UID拆分，核心不依赖长尾&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;单元化的实现思路：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;水平拆：交易、支付、账务等,每个单元只有部分数据&lt;/li&gt;
&lt;li&gt;上层单元化改造：从DB层往上延伸水平拆分概念,包括应用层到入口层&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在容灾同步上，是基于单元化的多中心同步，这已打破我们对原有容灾备份的认识，基于单元化的容灾同步，可以细粒度的控制，解决数据一致性和时效性问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;基于DB同步的数据复制：延时非敏感业务的异地复制方案;部分业务数据,可忍受3s时效性延迟(比如大部分的配置 数据)&lt;/li&gt;
&lt;li&gt;基于消息系统的数据复制：对于延时非常敏感的业务,更低延时的实现方案;上层基于应用进行复制,减少延时。底层 DB主备同步同时进行&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;高效运维&#34;&gt;高效运维&lt;/h3&gt;

&lt;p&gt;开发团队快节奏的版本迭代，以及服务的快速上线的要求，驱动着PaaS平台要提供出更为高效的运维服务。高效运维的思路是建立以 &lt;strong&gt;应用服务&lt;/strong&gt; 为核心的管理标准体系。把运维能力服务化(API)，使运维的能力无处不在。高效运维，综合几个公司的介绍主要需要如下几个系统设计：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;发布系统：负责应用服务的上线，应用服务的资源管理，扩容，权限管理，支持Beta发布，灰度升级。&lt;/li&gt;
&lt;li&gt;监控系统：通用+自定义监控配置,运维+开发可以时刻关注自己的服务状态和质量。&lt;/li&gt;
&lt;li&gt;全链路系统：复杂的分布式系统，一次点击，几十次的RPC调，需要全链路跟踪，出了问题,如何快 速定位到故障点。&lt;/li&gt;
&lt;li&gt;限流与降级：限流,Web层,防止被流量打垮；降级,App层(服务化),保障核心应用&lt;/li&gt;
&lt;li&gt;容量评估：基于全链路的压测手段、数据分布的模拟方法、关键场景调用量预估&lt;/li&gt;
&lt;li&gt;蓝绿发布：即多站点的灰度。具体操作流程：切流（将待发布机房流量切走）-&amp;gt; 机房发布（待发布机房全应用并行发布）-&amp;gt; 引流验证 （逐步按规则引流至100%）-&amp;gt;
  流量交换（将全部流程切换到已发布机房）-&amp;gt; 机房发布（另一个机房全应用并行发布）-&amp;gt; 分流还流（分流规则还原，两机房各50%）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;服务化&#34;&gt;服务化&lt;/h2&gt;

&lt;p&gt;今年IT界是对服务化异常的火爆，系统的稳定和流畅依赖好的应用架构，服务化治理如何规划和落地，是众多厂商系统的痛点。&lt;/p&gt;

&lt;p&gt;首先是来自1号店订单系统对SOA化的分享，SOA是一种架构模式,是设计原则,不是技术规范。狭义的SOA：Service化， 标准化、模块化、组件化。广义的SOA：模式、原则、思想。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Service化：1）分层结构，基础Service不含业务逻辑,只封装基本的数据操作。业务(聚合)Service封装业务逻辑甚至是全部的业务逻辑。2）Service层次调用，上层可以调用下层、下层不可调用上层、同层间可互相调用，调用链长度不超过3级、不循环调用。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;服务粒度划分：1）迷你裙定律。2）细粒度的服务(fine-grained)提供相对较小的功 能单元,或交换少量的数据。细粒度的服务使服务更容易被组装。3）粗粒度的服务(coarse-grained)则是在一个抽象 的接口中封装了独立的业务/技术能力,减少服务请求交互的次数。粗粒度的服务适合更广泛的需求。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;再次是来自Twitter的服务化思路分享：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;单体：牵一发而动全身&lt;/li&gt;
&lt;li&gt;分拆：把单体分成多个模块&lt;/li&gt;
&lt;li&gt;服务化：把模块按功能服务化&lt;/li&gt;
&lt;li&gt;平台化：模块功能中部分服务化为通用服务，通用服务提供一般化服务，平台化&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;docker&#34;&gt;Docker&lt;/h2&gt;

&lt;p&gt;在不断寻求性能更好、速度更快、成本更低的云计算核心技术中，容器技术是目前最吸引人注意的技术之一。尽管除去效率、速度和成本等方面的优势以外，容器技术还存在一些安全上需要斟酌的问题，但是其实际表现仍然得到了肯定。还是借用其中的分享内容来说明一下Docker。&lt;/p&gt;

&lt;p&gt;在遇到Docker之前：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;混乱的环境：Java, Golang, Ruby&lt;/li&gt;
&lt;li&gt;混乱的配置：Upstart, authorized_keys, dependency, 各种脚本&lt;/li&gt;
&lt;li&gt;混乱的监控：ErrorReporter, Message&lt;/li&gt;
&lt;li&gt;混乱的资源：计算资源与预估不匹配&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;导致的结果是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;环境不匹配导致,测试跟生产不一致&lt;/li&gt;
&lt;li&gt;配置混乱导致事故频发&lt;/li&gt;
&lt;li&gt;监控不统一导致运维难上加难&lt;/li&gt;
&lt;li&gt;资源效率低导致成本很高却达不到相应目标&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而Docker具有如下特点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;构建快：应用+运行环境 = 镜像&lt;/li&gt;
&lt;li&gt;启动快：容器相比于虚机,更轻量级&lt;/li&gt;
&lt;li&gt;迁移快：应用以容器的方式标准化交付,标 准化运行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;去年Docker主要是在吵作概念，而今年很多的互联网厂商已在使用Docker，本次Docker中都分享各自针对Docker的一些定制化修改及踩过的各种坑，所遇到的困难和走过的弯路。&lt;/p&gt;

&lt;p&gt;当然这些坑不是阻当我们不使用Docker的理由，Dockerk只是一个系统架构优化的承载体。来自Coding.net的分享最后总结的比较好，Docker会对软件，流程带入变革与影响，是否采用Docker，系统都需要关注如下三个方面，只是Docker让你不得不关注他们：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;软件架构的升级：微服务、无状态、数据执行分离&lt;/li&gt;
&lt;li&gt;研发体系、环境管理理念的升级：容器化、代码化、自动化&lt;/li&gt;
&lt;li&gt;资源管理理念的升级：Pet vs Cattle，多留点富余量，迁移能力比压榨能力更重要&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>配置与定制</title>
      <link>http://lanlingzi.cn/post/technical/2015/0813_cfg_vs_cus/</link>
      <pubDate>Thu, 13 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2015/0813_cfg_vs_cus/</guid>
      <description>&lt;p&gt;作为一个软件人员，我们会经常遇到各种各样的需求，有时为了避免定制，通常的做法是提供更多的配置选项，以通过配置出满足不同的特定需求。&lt;/p&gt;

&lt;p&gt;原因是而当你开发定制代码来修改或扩展一个功能需求时，有可能会导致软件不能正常的工作，必须通过严格的测试与验证。在重大的版本升级情况下，定制是苛刻的和耗时的。甚至会面临无法修复的功能可能会被重构，从零开始。因此，一些做法是通过采越来越多地选择配置，来解决由于开发定制代码引入的问题与软件带来的成本。&lt;/p&gt;

&lt;p&gt;因此配置与定制之间的区别是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;配置：使用现有的数据来配置系统以满足您的业务需求&lt;/li&gt;
&lt;li&gt;定制：将定制或使系统适应业务需求，涉及到定制开发流程。
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作为一名开发或设计人员，重要的是要了解不同的配置和定制的区别，差异的关键是复杂度。配置使用的软件具有固有的灵活性，如添加字段，更改字段名称，修改下拉列表，或添加按钮。配置是使用强大的内置功能集。而定制是包括代码更改以创建出不可通过配置解决的功能。定制可能是昂贵的，并且可能会使软件的升级复杂化，因为由于代码变更可能不会很容易迁移到新版本。像“修改”或“扩展”往往意味着不同的东西，存在不确认的风险。&lt;/p&gt;

&lt;p&gt;要避免定制，提供的一些配置工具并不总是一个较简单的选择。但这些配置选项如何配合业务运行时，也会让运维人员无所事从，太多的配置选项最终变成谁也不敢去使用，因为无法去评估配置带来的运行期的影响。一种方式是提供向导驱动的配置，但同样面临没有在初始部署时掌握他们的细节和晦涩深奥的设置。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>微服务与SOA</title>
      <link>http://lanlingzi.cn/post/technical/2015/0516_microservice_soa/</link>
      <pubDate>Sat, 16 May 2015 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2015/0516_microservice_soa/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://martinfowler.com/articles/microservices/images/sketch.png&#34; alt=&#34;microservices&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我司学习一个新的技术，往往是搞得轰轰烈烈，比如数字化转型，向互联网技术学习。其中一个非常重要的方向就是学习互联网的服务化体系架构。国内的阿里，京东，腾讯在服务化，确切地说是微服务应用取得非常大的成功。而国外的Netflix的微服务架构更是成为我们必定的样板教材。你做设计，谈方案，不说说微服务都不好意思。如果你不说这样，说明你思维落后陈旧了。任何一项技术都有一段疯狂期，虽这近一次在搞架构重构，领导遇到你，总是关心地问到：“服务化进展怎么样了”。甚至还得跟一些不太懂的领导解释什么是微服务。&lt;/p&gt;

&lt;p&gt;10年前差不到了SOA也像今天的微服务一样火爆。那微服务与SOA的关系或区别是什么？是不是SOA的旧洒换新瓶？软件界的大牛 Martinfowler的《&lt;a href=&#34;http://martinfowler.com/articles/microservices.html&#34;&gt;微服务&lt;/a&gt;》更是像一部微服务的圣经，无奈是E文，大家都有各自的理解。在我司更是大家对这个各抒己见，谁都可以说上几句服务化的原则是什么，微服务成了领导专家们口里的口头禅。如果我们的系统不是微服务化，都怀疑我们系统的先进性。想当初，大家也都谈SOA，也极力推广SOA。似乎到了今天，微服务与SOA两者是势不相容。SOA是传统的IT架构，而微服务是当今互联网架构，微服务似乎比SOA更“逼格”。甚至这样的争论成了不同兄弟的心头痛。
&lt;/p&gt;

&lt;p&gt;那先来看看Martinfowler怎么说的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;微服务风格也与SOA所提倡的一些优势非常相似。尽管如此，问题在于SOA意味的太多&lt;a href=&#34;http://martinfowler.com/bliki/ServiceOrientedAmbiguity.html&#34;&gt;不同的东西&lt;/a&gt;了，因此通常时候我们谈的所谓“SOA”时，它与我们谈论的风格不一致，因为它通常是指在整体风格应用中的ESB。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;从试图使用ESB隐藏复杂性，到集中治理模式抑制变更，这种面向服务的风格是复杂的，没有ESB什么都不是。互联网的发展，利用简单的协议方法，让它从这些经验传达的出来。可能说对SOA集中式标准中的一种反模式，而SOA需要用一个服务来管理你的所有的服务，你就知道这很麻烦。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;SOA的这种常见行为让微服务的提倡者拒绝打上SOA的标签，尽管有人认为微服务是从SOA中发展而来的，或许面向服务是对的。无论如何，事实上SOA表达这么多的含义，它给一个团队清醒的认识到这种构架风格就已经值的了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;至少Martinfowler在面向服务体系中，微服务是从SOA发展出来的，只是大家受到SOA的伤害而不太愿意打上SOA的标签。他们本质与出发点是相同的。微服务是细粒度的SOA，你不用去关心“庞大的”ESB，也不用去熟悉大堆的WS-*术语。当服务变得微小（micro）时，服务可能是由规模恰当的团队（12个人）制定的，也可能是单个人制定的。&lt;/p&gt;

&lt;p&gt;我们没有办法对微服务进行准确的定义，怎么去划分服务，什么算是微服务？两个比萨能吃饱的团队（12个人）也说得太抽象了，在面对具体的实践来说，到底怎么才是SOA中微小服务，我们又如何去分析与设计？以为团队中的成员能力来划分，学是以业务功能集来划分，再去组织团队？这些问题都是我们在实践中面对的挑战。&lt;/p&gt;

&lt;p&gt;微服务架构中的“微”体现了其核心要素，即服务的微型化，就是每个服务微小到只需专注做好一件事。 这件事紧密围绕业务领域，形成高度内聚的自治性。&lt;/p&gt;

&lt;p&gt;微服务架构强调“微”，与之前有些采用了SOA服务化架构思想的系统搞出很多胖服务来说，一点也不微，这依然带来耦合。 这一点只能依赖系统架构师的服务化建模能力了，但微服务架构强调每个服务一个进程， 使用进程为边界来隔离代码库至少让同一应用系统不同层次的开发人员享有自己完全自治的领地，每个微服务都有一个掌控者。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://book.douban.com/subject/25881698/&#34;&gt;《Building Microservices》&lt;/a&gt;一书对实施微服务架构有系统性的描述和很多业界案例的简单引用描述，这里不展开讲实施细节，那样就太长了。简单总结下实施的要点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;自动化文化与环境：自动构建、自动测试、自动部署。&lt;/li&gt;
&lt;li&gt;围绕业务能力建模服务，松耦合、高内聚、暴露接口而隐藏实现细节。&lt;/li&gt;
&lt;li&gt;服务协作模型：中心化（乐队模型：中心指挥）和去中心化（舞蹈模型：群舞自组织），各自场景不同。&lt;/li&gt;
&lt;li&gt;服务交互方式：RPC/REST/WS 技术很多但考虑统一。&lt;/li&gt;
&lt;li&gt;服务部署：独立性、失败隔离性、可监控性。&lt;/li&gt;
&lt;li&gt;服务流控：降级、限流&lt;/li&gt;
&lt;li&gt;服务恢复：多考虑故障发生如何快速恢复而非如何避免发生故障。&lt;/li&gt;
&lt;li&gt;服务发布：灰度。&lt;/li&gt;
&lt;li&gt;服务部署：一服务一主机模型，需要虚拟化(Hypervisor)、容器化(LXC, Docker)等技术支持，实现硬件资源隔离。&lt;/li&gt;
&lt;li&gt;服务配置：中心化配置服务支持&lt;/li&gt;
&lt;li&gt;康威定律：任何设计系统的组织，最终产生的设计等同于组织之内、之间的沟通结构。系统架构的设计符合组织沟通结构取得的收益最大。&lt;/li&gt;
&lt;li&gt;伯斯塔尔法则：服务健壮性原则 —— 发送时要保守，接收时要开放。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;注：部分参考 &lt;a href=&#34;http://mindwind.me/blog/2015/05/14/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5%E6%84%9F%E6%82%9F.html&#34;&gt;《微服务架构实践感悟》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>架构重构</title>
      <link>http://lanlingzi.cn/post/technical/2015/0430_arch_refactor/</link>
      <pubDate>Tue, 12 May 2015 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2015/0430_arch_refactor/</guid>
      <description>&lt;p&gt;最近一直在做系统架构上重构工作，理论不能不学习啊，只有在思想上把自己武装起来，才能减少我们工作上的错误。之前参加过或亲自操刀过多次的代码局部或模块重构，但这一次架构重构是范围波及最广，收获颇多。&lt;/p&gt;

&lt;h2 id=&#34;什么是重构&#34;&gt;什么是重构&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;重构是指在不修改代码外在行为的前提下，对代码做出的修改，以改进程序的内部结构，提高其可理解性，降低其修改成本。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这是来自马大神的《重构》一书对重构释义。重构可以改进软件设计；使软件更容易理解；使软件更容易维护；帮助找到软件Bugs；帮助提高编程效率。重构按对系统修改的粒度层次可以分为如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;局部代码重构，操作与实施比较容易，《重构》一书中介绍了大量经典的方法。&lt;/li&gt;
&lt;li&gt;模块级代码重构，可能涉及到模块之间的接口重构，操作与实施难度相对适中。&lt;/li&gt;
&lt;li&gt;架构重构，是对整个系统架构层次的重构，牵系相当的广，操作与实施难度比较高。
&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;重构风险&#34;&gt;重构风险&lt;/h2&gt;

&lt;p&gt;无论何种层次的重构，都必须要有一个可靠的测试环境，即自动化测试环境。因为频繁的代码修改可能会引入更多的缺陷，只有执行自动化测试并回归所有用例，才能保证及时发现这些缺陷，最大限度地降低重构的风险。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;局部的不良代码，可以通过小范围的重构来优化。但是对于架构上重构，因为重构影响范围过大，在实践中仍然存在绪多的困难。&lt;/li&gt;
&lt;li&gt;架构上大的重构，至少几十人的投入，更需要半年到一年的开发周期。在老软件不能停止维护的前提下，这对开发人力将产生巨大冲击。&lt;/li&gt;
&lt;li&gt;新架构虽然先进，但历史经验表明，新软件的成熟与稳定需要时间。在沉重的交付压力下，风险需要做很多的预防控制。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;为什么要重构&#34;&gt;为什么要重构&lt;/h2&gt;

&lt;p&gt;给老大说明重构的意义往往很难，尤其不是技术出身的管理者，即使是，也需要面临交付上的考虑。从技术上讲，为什么要重构：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不论如何先进的软件架构也不可能预见到几年甚至十几年后的需求，并预先设计&lt;/li&gt;
&lt;li&gt;随着新功能的不断增加，以及新成员的加入，软件架构必然逐渐腐化&lt;/li&gt;
&lt;li&gt;虽然强力的架构看护制度可以延缓架构腐化的速度，但不可能看护到实现细节&lt;/li&gt;
&lt;li&gt;重构则提供了软件持续优化的机会，从而使软件更容易适应新的需求，同时及时地改进不合理的部分&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;重构与重写&#34;&gt;重构与重写&lt;/h2&gt;

&lt;p&gt;对于一次重构来说区别不大，只是力度不同，重构侧得局部优化，也会重用现有的资产，重构的极端就是重写。他们的主要区别是重构强调的是持续的，随时的优化，而重写强调的是一次性的天翻地覆的改造。那我们如何判断是要重构还是重写？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;重构是持续的，并不是等到极端恶心才开始优化，所以坚持持续的重构可以代价更小的达到优化的目的&lt;/li&gt;
&lt;li&gt;若已经极端恶化的模块，重写也是一种解决方式，但要注意避免失控，须在设计、测试、管理、人员能力等多方面要做好准备&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;何时重构&#34;&gt;何时重构&lt;/h2&gt;

&lt;p&gt;何时重构，因项目因人员能力而异：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不同粒度层次的重构，重构的时机选择应该是不同的&lt;/li&gt;
&lt;li&gt;不同粒度层次的重构，实施的节奏也必然不同的&lt;/li&gt;
&lt;li&gt;关键技术需要提前原型验证，风险评估&lt;/li&gt;
&lt;li&gt;对于模块级，架构级重构，通常在添加新功能或特性之前充分考虑，留出部分空档期来重构&lt;/li&gt;
&lt;li&gt;制定重构计划，步步为营，切忌全面开花，导致风险不可控&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;同时在重构时，需要平衡重构与交付：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;为了交付而不重构，是恶性循环，最终交付的压力会越来越大，质量会越来越差&lt;/li&gt;
&lt;li&gt;对于模块级，架构级重构，应该是有计划地落入到迭代版本中&lt;/li&gt;
&lt;li&gt;可以采用冬虫夏草的方式重构，逐步重构或替换，随时（至少每个迭代）可以保证系统的完整性&lt;/li&gt;
&lt;li&gt;注意控制每次迭代重构的范围，要分析并划分合理的重构边界&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;重构人员&#34;&gt;重构人员&lt;/h2&gt;

&lt;p&gt;重构最终落实还是人员能力，对于参与的人员能力要求：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;知道重构的意义，重构需要有个人强烈的意愿，才能有所突破&lt;/li&gt;
&lt;li&gt;对现有的组件流程与实现非常地清楚&lt;/li&gt;
&lt;li&gt;针对性强，能够熟练地运用各种重构方法&lt;/li&gt;
&lt;li&gt;能够察觉出实现的问题，能提出改进（重构）建议（方案）&lt;/li&gt;
&lt;li&gt;经验是基础，对构架本身的体系有较为深厚的理解和应用经验&lt;/li&gt;
&lt;li&gt;不同层级的重构，需要不同的参与，不同阶段投入&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;重构中有哪些角色，他们职责是什么&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SA/SE（系统架构师，系统设计师）：负责按照架构正确地设计与分解需求，能清楚系统中的痛点，以及各组件的主要问题&lt;/li&gt;
&lt;li&gt;SE/MDE（系统设计师，模块设计师）：负责某个组件整体看护，设计组件内疗实现机制，系统约束等&lt;/li&gt;
&lt;li&gt;SWE（软件工程师）：在软件架构的基础上，负责具体的功能实现。&lt;/li&gt;
&lt;li&gt;TE（测试工作师）：补充用例，执行自动化测试，及时发现系统中的缺陷，并与SWE结队处理问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;总之，重构要务实，务实就是尊重现实，基于现实情况分析与实施，不断地推进演化。架构重构不仅需要充分的设计，切实有效的重构操作方法也非常地重要。架构重构，抛开代码搞理论上的重构不行；充分利用代码，但又不能掉进“代码泥潭”。无论怎么重构，一定要构建夯实的测试防火墙，快速反馈重构中的问题。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>