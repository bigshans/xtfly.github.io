<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>P2p on 蘭陵N散記</title>
    <link>http://lanlingzi.cn/tags/p2p/index.xml</link>
    <description>Recent content in P2p on 蘭陵N散記</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <atom:link href="http://lanlingzi.cn/tags/p2p/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Taipei-Torrent源码分析</title>
      <link>http://lanlingzi.cn/post/technical/2016/0117_torrent_go/</link>
      <pubDate>Sun, 17 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2016/0117_torrent_go/</guid>
      <description>&lt;p&gt;提到P2P，总会少不了BitTorrent。BitTorrent是一种P2P协议。BitTorrent协议是由程序员Bram Cohen在2001年四月份设计的，最终版本在2008年确定。&lt;/p&gt;

&lt;h2 id=&#34;bittorrent协议简介&#34;&gt;BitTorrent协议简介&lt;/h2&gt;

&lt;p&gt;一个BitTorrent的文件在网络传输过程，由以下几个部分组成：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;WEB服务器&lt;/li&gt;
&lt;li&gt;文件元信息(metainfo)&lt;/li&gt;
&lt;li&gt;BitTorrent Tracker&lt;/li&gt;
&lt;li&gt;原始资源发布者&lt;/li&gt;
&lt;li&gt;目的端用户浏览器&lt;/li&gt;
&lt;li&gt;目的端用户下载者
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中原始资源发布者与目的端下载者都称为Peer，而Tracker主要用于获取不同的Peer信息信息，BitTorrent把要下载文件虚拟分成大小相等的块，并把每块的索引信息与Hash验证码等元数据信息写到一个.torrent文件中，即种子文件。种子文件采用B编码格式，它本质是一个文本。Peer与Tacker或DHT节点通讯也采用B编码格式。根据获取Peer信息的途径不同，又分为两种。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;有的Tracker结构&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;		[WebServer]
		  |
		  | torrent file
		  |
	 [  Peer ] ---Get Peers --- [TrackerServer]
	     \
	      \
	      Download&amp;amp;Upload(TCP)
	       \
	        \
	       [ OtherPeer ]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Trackerless的DHT结构&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;		[WebServer]
		  |
		  | torrent file
		  |
	 [  Peer ] ---Get Peers --- [DHT Nodes]
	     \
	      \
	      Download&amp;amp;Upload(TCP)
	       \
	        \
	       [ OtherPeer ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Trackerless的DHT结构解决了Trakcer中心故障的问题，是一个更去中化的结构。DHT结构中，每个peer都可能是一个tracker。DHT是基于Kademila协议的，并且在UDP协议基础上实现。&lt;/p&gt;

&lt;p&gt;每个节点都有一个全局唯一的标识符，称为节点ID。距离度量用来比较两个节点或者节点与infohash之间的远近程度。节点必须维护一个含有少量其他节点联系信息的路由表。ID越靠近自身ID时，路由表越详细。节点知道很多离它很近的节点，只知道少量离它很远地节点。&lt;/p&gt;

&lt;p&gt;在Kademlia中，距离度量采用异或计算，结果解释成一个无符号整数。 distance (A,B)=(A ~| B)，值越小，距离越近。每个节点维护一个路由表，由它所知道的好节点组成。路由表中的节点被用作在DHT中发送请求的起点。当其他节点查询时，就返回路由表中的节点。&lt;/p&gt;

&lt;h2 id=&#34;开源实现&#34;&gt;开源实现&lt;/h2&gt;

&lt;h3 id=&#34;c-语言&#34;&gt;C++语言&lt;/h3&gt;

&lt;p&gt;实现BitTorrent协议最有名要算两个C++的实现：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rakshasa/libtorrent&#34;&gt;rakshase&lt;/a&gt; 版本：他来源于Mozilla NSS的项目，LICENSE是GPL，使用它的客户端亦rtorrent等，基于Posix接口开发，可以在兼容Posix系统中编译使用，也支持HDT。这个项目已有12年了，目前还在发展，可以是非常的稳定与成熟，据说是速度之王。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/arvidn/libtorrent&#34;&gt;rasterbar(arvidn/libtorrent)&lt;/a&gt;版本，GitHub上有两个地址，另一个是&lt;a href=&#34;https://github.com/libtorrent/libtorrent&#34;&gt;libtorrent/libtorrent&lt;/a&gt;。前者是还是发展，后者已停止开发了。rasterbar版本是基于boost asio编写的，跨平台不存问题。默认有Python与Ruby的绑定接口。并且具有良好扩展性，例如有uTP，DHT安全扩展&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;go语言&#34;&gt;Go语言&lt;/h3&gt;

&lt;p&gt;由于个人爱好的原因，一真想找是否有Go语言实现版本，于是在GitHub上寻寻觅觅，也找到两个不错的实现：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jackpal/Taipei-Torrent&#34;&gt;Taipei Torrent&lt;/a&gt;：它一个较轻量的，基于命令行接口的Torrent客户端，主要功能有支持多Torrent文件，Magnet链接，DHT，UPnP/NAT-PMP打洞，也提供简单的tracker服务。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/anacrolix/torrent&#34;&gt;anacrolix/torrent&lt;/a&gt;: 它实现了BitTorrent协议相关功能包，以及提供较丰富的命令行工具集。支持加密协议，DHT，PEX，uTP以及多种扩展。从代码结构来说，anacrolix/torrent比Taipei Torrent更容易做二次开发。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;taipei-torrent&#34;&gt;Taipei Torrent&lt;/h2&gt;

&lt;p&gt;首先它的名字比较有意思，项目开始于作者在台北的旅游，所以取名为&lt;code&gt;Taipei Torrent&lt;/code&gt;。它的代码量比较不多，像Bencode，DHT，NAT-PMP，网络工具包都采用第三方库。&lt;/p&gt;

&lt;h3 id=&#34;代码结构&#34;&gt;代码结构&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Taipei-Torrent git:(master) tree
├── main.go
├── queryTracker.bash
├── resolveBindIP.go
├── resolveBindIP_test.go
├── test.bash
├── testData
│   ├── a.torrent
│   └── testFile
├── testdht.bash
├── testswarm.bash
├── testtracker.bash
├── torrent
│   ├── accumulator.go
│   ├── accumulator_test.go
│   ├── bitset.go
│   ├── cache.go
│   ├── cache_test.go
.......
│   ├── upnp.go
│   ├── uri.go
│   └── uri_test.go
└── tracker
    ├── tracker.go
    └── tracker_test.go
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;源码分析&#34;&gt;源码分析&lt;/h3&gt;

&lt;p&gt;花了一个下午走读它的代码，代码简洁易懂，主要功能都在&lt;code&gt;torrent&lt;/code&gt;目录下。每个Peer对一个torrent文件会产生一个会话，在我的笔记本记，使用Docker搭建了6个节点，发布下载77M的go的安装包，是秒级速度。如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2016/01/17 12:13:13 Starting.
2016/01/17 12:13:13 Listening for peers on port: 7777
2016/01/17 12:13:13 [ go1.5.3.linux-amd64.tar.gz ] Tracker: [], Comment: , InfoHash: 556871e1ada306c2da5033e8fe0d4f077edbe6f7, Encoding: , Private: 0
2016/01/17 12:13:13 [ go1.5.3.linux-amd64.tar.gz ] Computed missing pieces (0.35 seconds)
2016/01/17 12:13:13 [ go1.5.3.linux-amd64.tar.gz ] Good pieces: 0 Bad pieces: 1223 Bytes left: 80147269
2016/01/17 12:13:13 Created torrent session for go1.5.3.linux-amd64.tar.gz
2016/01/17 12:13:13 Starting torrent session for go1.5.3.linux-amd64.tar.gz
2016/01/17 12:13:14 [ go1.5.3.linux-amd64.tar.gz ] Peers: 0 downloaded: 0 (0.00 B/s) uploaded: 0 ratio: 0.000000 pieces: 0/1223
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;作为Peer Client，主要代码逻辑在&lt;code&gt;torrent\torrentLoop.go&lt;/code&gt;的RunTorrents方法中，它充分利用了Go的channel机制。实现步骤如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;根据命令参数，开启Peer连接端口（TCP）。若不指定端口，则采用随机端口。目前是绑定在所的IP上，如果是内网，可以做NAT转换。&lt;/li&gt;
&lt;li&gt;根据MaxActive参数，开启Session（对象为TorrentSession）数，如果同时下载torrent多余MaxActive则排队处理&lt;/li&gt;
&lt;li&gt;如果设置参数useDHT，或torrent文件中没有Tracker服务，则会开启DHT，而DHT是采用UDP，端口与第1步的相同。&lt;/li&gt;
&lt;li&gt;如果设置useLPD（Use Local Peer Discovery），则又会通过组播在同一个网段内相互发现，组播地址为&lt;code&gt;239.192.152.143:6771&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;当完成上述初始化之后，在mainLoop主要根据事件来处理：

&lt;ol&gt;
&lt;li&gt;如果是Session创建成功，则异步执行&lt;code&gt;TorrentSession.DoTorrent&lt;/code&gt;方法开始启动下载&lt;/li&gt;
&lt;li&gt;如果是有Session下载结束，则从排队中取出未处理的torrent文件加入到Session处理。&lt;/li&gt;
&lt;li&gt;如果是收到退出信号，则等下载结束退出。&lt;/li&gt;
&lt;li&gt;如果是收到其它Peer的连接请求，根据Infohash来判断是否存在相应的Session，如果存在，则提供给其它的Peer下载数据。&lt;/li&gt;
&lt;li&gt;如果是收到DHT Peer的请求结果，则处理其它的Peer地址，根据地址从其它Peer下载数据。&lt;/li&gt;
&lt;li&gt;如果是收到其它Peer的组播请求，则处理其它的Peer地址，根据地址从其它Peer下载数据。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;另一个核心代码逻辑是在&lt;code&gt;torrent\torren.go&lt;/code&gt;的DoTorrent方法中，实现步骤如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果设置了内存缓存或硬盘缓存数，则根据torrent文件中元信息（块个数，整个大小）初始化缓存。&lt;/li&gt;
&lt;li&gt;开启几个定时器，每隔1秒心跳检查，每隔60秒连接KeepAlive，如果采用Tracker服务，每隔20秒与Tracker服务列表请求，直到有Tracker服务有咱应。&lt;/li&gt;
&lt;li&gt;如果是DHT，则从DHT Peer获取其它的Peer地址。&lt;/li&gt;
&lt;li&gt;处理各种Channel的消息。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;还一个重要的&lt;code&gt;torrent\torren.go&lt;/code&gt;的DoMessage方法，它用于是产生协议的消息，与一个peer建立TCP连接后，首先向peer发送握手消息，peer收到握手消息后回应一个握手消息。握手消息是一个长度固定为68字节的消息。消息的格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[pstrlen][pstr][reserved][info_hash][peer_id]
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参    数&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;含    义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pstrlen&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;pstr的长度，该值固定为19&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pstr&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;BitTorrent协议的关键字，即“BitTorrent protocol”&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;reserved&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;占8字节，用于扩展BT协议，一般这8字节都设置为0。有些BT软件对BT协议进行了某些扩展，因此可能看到有些peer发来的握手消息这8个字节不全为0，不过不必理会，这不会影响正常的通信&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;info_hash&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;与发往Tracker的GET请求中的info_hash为同一个值，长度固定为20字节&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;对于除握手消息之外的其他所有消息，其一般的格式为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[length prefix][message ID][payload]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;length prefix（长度前缀）占4个字节，指明message ID和payload的长度和。message ID（消息编号）占一字节，是一个10进制的整数，指明消息的编号。payload（负载），长度未定，是消息的内容。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;keep_alive消息：[len=0000]&lt;/p&gt;

&lt;p&gt;keep_alive消息的长度固定，为4字节，它没有消息编号和负载。如果一段时间内客户端与peer没有交换任何消息，则与这个peer的连接将被关闭。keep_alive消息用于维持这个连接，通常如果2分钟内没有向peer发送任何消息，则发送一个keep_alive消息。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;choke消息：[len=0001][id=0]&lt;/p&gt;

&lt;p&gt;choke消息的长度固定，为5字节，消息长度占4个字节，消息编号占1个字节，没有负载。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;unchoke消息：[len=0001][id=1]&lt;/p&gt;

&lt;p&gt;unchoke消息的长度固定，为5字节，消息长度占4个字节，消息编号占1个字节，没有负载。客户端每隔一定的时间，通常为10秒，计算一次各个peer的下载速度，如果某peer被解除阻塞，则发送unchoke消息。如果某个peer原先是解除阻塞的，而此次被阻塞，则发送choke消息。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;interested消息：[len=0001][id=2]&lt;/p&gt;

&lt;p&gt;interested消息的长度固定，为5字节，消息长度占4个字节，消息编号占1个字节，没有负载。当客户端收到某peer的have消息时，如果发现peer拥有了客户端没有的piece，则发送interested消息告知该peer，客户端对它感兴趣。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;not interested消息：[len=0001][id=3]&lt;/p&gt;

&lt;p&gt;not interested消息的长度固定，为5字节，消息长度占4个字节，消息编号占1个字节，没有负载。当客户端下载了某个piece，如果发现客户端拥有了这个piece后，某个peer拥有的所有piece，客户端都拥有，则发送not interested消息给该peer。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;have消息：[len=0005][id=4][piece index]&lt;/p&gt;

&lt;p&gt;have消息的长度固定，为9字节，消息长度占4个字节，消息编号占1个字节，负载为4个字节。负载为一个整数，指明下标为index的piece，peer已经拥有。每当客户端下载了一个piece，即将该piece的下标作为have消息的负载构造have消息，并把该消息发送给所有与客户端建立连接的peer。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;bitfield消息：[len=0001+X][id=5][bitfield]&lt;/p&gt;

&lt;p&gt;bitfield消息的长度不固定，其中X是bitfield(即位图)的长度。当客户端与peer交换握手消息之后，就交换位图。位图中，每个piece占一位，若该位的值为1，则表明已经拥有该piece；为0则表明该piece尚未下载。具体而言，假定某共享文件共拥有801个piece，则位图为101个字节，位图的第一个字节的最高位指明第一个piece是否拥有，位图的第一个字节的第二高位指明第二个piece是否拥有，依此类推。对于第801个piece，需要单独一个字节，该字节的最高位指明第801个piece是否已被下载，其余的7位放弃不予使用。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;request消息：[len=0013][id=6][index][begin][length]&lt;/p&gt;

&lt;p&gt;request消息的长度固定，为17个字节，index是piece的索引，begin是piece内的偏移，length是请求peer发送的数据的长度。当客户端收到某个peer发来的unchoke消息后，即构造request消息，向该peer发送数据请求。前面提到，peer之间交换数据是以slice（长度为16KB的块）为单位的，因此request消息中length的值一般为16K。对于一个256KB的piece，客户端分16次下载，每次下载一个16K的slice。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;piece消息：[len=0009+X][id=7][index][begin][block]&lt;/p&gt;

&lt;p&gt;piece消息是另外一个长度不固定的消息，长度前缀中的9是id、index、begin的长度总和，index和begin固定为4字节，X为block的长度，一般为16K。因此对于piece消息，长度前缀加上id通常为00 00 40 09 07。当客户端收到某个peer的request消息后，如果判定当前未将该peer阻塞，且peer请求的slice，客户端已经下载，则发送piece消息将文件数据上传给该peer。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;cancel消息：[len=0013][id[=8][index][begin][length]&lt;/p&gt;

&lt;p&gt;cancel消息的长度固定，为17个字节，len、index、begin、length都占4字节。它与request消息对应，作用刚好相反，用于取消对某个slice的数据请求。如果客户端发现，某个piece中的slice，客户端已经下载，而客户端又向其他peer发送了对该slice的请求，则向该peer发送cancel消息，以取消对该slice的请求。事实上，如果算法设计合理，基本不用发送cancel消息，只在某些特殊的情况下才需要发送cancel消息。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;port消息：[len=0003][id=9][listen-port]
*
port消息的长度固定，为7字节，其中listen-port占两个字节。该消息只在支持DHT的客户端中才会使用，用于指明DHT监听的端口号，一般不必理会，收到该消息时，直接丢弃即可。
&amp;gt; 注：Taipei Torrent未实现此消息&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;extension消息：[len=0009+X][id=20][payload]&lt;/p&gt;

&lt;p&gt;extension消息消息的长度不固定，消息Id为20， Taipei Torrent来来与其它的Peer交换torrent文件的元数据信息（每块Pieces的信息），同样采用B编码格式。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>软件分发加速</title>
      <link>http://lanlingzi.cn/post/technical/2016/0116_speed_sw_distribute/</link>
      <pubDate>Sat, 16 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2016/0116_speed_sw_distribute/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://image.xinmin.cn/2011/04/06/20110406151112514943.jpg&#34; alt=&#34;balance&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;

&lt;p&gt;在云环境下，服务器（物理机）或虚拟机越来越多，存在同一个应用软件需要大规模地部署场景。传统的方式下是搭建一个软件仓库，由物理机或虚拟机节点直接从软件仓库下载。如果采用sftp或http协议，则只能做到从一个中心软件仓库分发软件包给其它的节点，若给上百台的节点同时分发同一软件包，则存在受带宽、负载限制等因素，导致分发的速度就会比较慢。
&lt;/p&gt;

&lt;h2 id=&#34;常用技术&#34;&gt;常用技术&lt;/h2&gt;

&lt;h3 id=&#34;组播&#34;&gt;组播&lt;/h3&gt;

&lt;p&gt;传统的IP通信有如下三种方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;单播（Unicast）：源主机与目的主机之间点对点的通信。&lt;/li&gt;
&lt;li&gt;广播（Broadcast）：源主机与同一网段中所有其它主机之间一点对多点的通信。&lt;/li&gt;
&lt;li&gt;组播（Multicast）：源主机与一组目的主机之间一点对多点的通信。与广播不同的是组播组中的所有接收者都可收到同样的数据拷贝，并且只有组播组内的主机可以接收该数据，而其它主机则不能收到。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;组播技术有效地解决了单点发送、多点接收的问题。所以组播非常适合运用在云环境下的软件分发场景，单点到多点的高效数据传送，能够大量节约网络带宽、降低网络负载。&lt;/p&gt;

&lt;p&gt;一般情况下，在二层网络中，交换机会默认开启组播，但会对组播带宽进行抑制，防止网络风暴造成的影响。在实现应用中可以在交换机上设置合适的组播带宽。如果组播需要跨二层网络，需要在路由器上开启组播路由协议。&lt;/p&gt;

&lt;p&gt;组播组内的所有主机共享同一个地址，这种地址称为组播地址。组播地址是范围在224.0.0.0~239.255.255.255之间的IP地址。此范围内的所有地址的前4个二进制为都是“1110“。组播地址也被称为D类IP地址，与其它的A类、B类和C类地址相区别。组播组是开放的，主机可以在任何时候进入或离开组。
IANA(Internet Assigned Numbers Authority)组织负责分发永久组播地址。&lt;/p&gt;

&lt;p&gt;由于组播地址是开放的，在实现组播服务，需要在上层设计加入组播的认证机制，如采用IP白名单，或在自定义上层协议，会话协商时进做登录认证。&lt;/p&gt;

&lt;p&gt;组播是采有UDP，与单播UDP不同，前者必须考虑TTL(Time to live)值，它用IP数据包的头部的一个字节表示。
TTL通过限制IP包被丢弃前通过的路由器数目，来决定IP包的生存时间。IP包每通过一个路由器，TTL就减一，当TTL变为0，这个包就被丢弃。
TTL的一个作用是防止配置有误的路由器把包在路由器之间无限的来回传递，还有一个作用是限制组播的地理范围。&lt;/p&gt;

&lt;p&gt;由于UDP不可靠，会存在丢包的情况，在设计组播服务需要考虑对传包个数与内容的校验，以及重传机制，或者在最坏的情况，采用TCP的补偿传输。通常的做法是在另开TCP连接来控制组播的传输质量，而UDP是负责数据流。&lt;/p&gt;

&lt;p&gt;Java在1.7中，已支持MulticastSocket API。API比较低层，需要结合NIO一起使用，另外JGroup与Netty也对组播有更高层的封装。&lt;/p&gt;

&lt;h3 id=&#34;p2p&#34;&gt;P2P&lt;/h3&gt;

&lt;p&gt;P2P(Peer to Peer)端到端传输模型，与传统的C/S（Client-Server）模型相对应的。P2P与C/S都是单播。但C/S是集中由Server端来分发中转，所以当多个节点从Server下载软件时，对Server的流量与性能影响最大。而在P2P网络中，每个节点都是对等的。网络中的每个节点既能充当网络服务的请求者，又对其它节点的请求作出响应，提供资源和服务。&lt;/p&gt;

&lt;p&gt;P2P组网按是否有中心索引节点来分有三种：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;集中式P2P：存在中心服务器，保存所有节点信息与资源信息，其它节点通过它找到需要连接的节点与资源。&lt;/li&gt;
&lt;li&gt;无结构化P2P：节点同时作为客户端和服务器端，无中心服务器，无中心路由器。&lt;/li&gt;
&lt;li&gt;结构化P2P： 将网络中所有资源整理成一张巨大的表，表内包含资源的关键字与存入节点地址，这张表裸眼分割分别存储到网络中每个节点中。结构化组网常见有三种：

&lt;ul&gt;
&lt;li&gt;DHT结构&lt;/li&gt;
&lt;li&gt;树形结构&lt;/li&gt;
&lt;li&gt;网状结构&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在实现P2P技术中，需要考虑如下几点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可控性：由于P2P流量特征具有上下行流量对称的特性，这使得直接面向用户的接入网络需要相应提高所能承载上行流量的能力。&lt;/li&gt;
&lt;li&gt;安全性：P2P相对随机的端口号，难以实话实行有效地监测和管理，加大了日常维护的难度。&lt;/li&gt;
&lt;li&gt;效率性：对等的节点需要尽快地得到所需要文件块，需要有机制查找出节点已有文件块信息。&lt;/li&gt;
&lt;li&gt;可靠性：不能存在文件块永久丢失的情况，必须存在源节点是可靠的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，在私有云环境下的软件分发，需要同时考虑安全与可靠性。一般是采用集中式P2P，存在中心服务器，只不过这个中心服务器可以是集群的。每个节点与中心服务器建立控制连接，什么节点下载什么软件，从哪些节点来下载软件，由中心服务器根据不同节点的负载来做出决策。利用近播原则、分域调度的思想来尽可能控制P2P流程对网络节点的影响。&lt;/p&gt;

&lt;h2 id=&#34;实施建议&#34;&gt;实施建议&lt;/h2&gt;

&lt;p&gt;在我们的实际测试中，一个400M软件包，100个节点的分发场景下，组播速度大约是P2P的5倍右右。但组播只能在一个二层网络中，如果跨二层网络需要在路由器上开启组播功能。而一般出于安全等多因素考虑，路由器会禁掉。P2P在安全与可靠性更难以控制，以及会对网络节点的产生影响，甚到会影响节点的业务正常的性能。所以优先是选择组播，如果存在跨二层网络，可以部署多套软件仓库。P2P可以运用在组播不能使用，以及节点并发初始部署软件时，而节点上已运行业务时，则需要从P2P网络退出，不能长期做来提供服务的节点。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>