<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>软件重构 on 蘭陵N散記</title>
    <link>http://lanlingzi.cn/tags/%E8%BD%AF%E4%BB%B6%E9%87%8D%E6%9E%84/index.xml</link>
    <description>Recent content in 软件重构 on 蘭陵N散記</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <atom:link href="http://lanlingzi.cn/tags/%E8%BD%AF%E4%BB%B6%E9%87%8D%E6%9E%84/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>重构已死</title>
      <link>http://lanlingzi.cn/post/technical/2016/0123_refactor_death/</link>
      <pubDate>Sat, 23 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2016/0123_refactor_death/</guid>
      <description>&lt;p&gt;上周在食堂吃饭，遇到同事聊起最近的系统重构，她说这一批的新员工不如13年的一批，就一个看似简单的问题也是折腾很久，重构的周期越拉越长。我作为这次的重构的特性SE，可以说也是硬着头皮上。我是越来越反感重构，尤其是涉及到多个模块的重构。在新年的聚餐上，我说我给你挖了坑，你来填坑，让我感到非常惭愧的，即又不得做这些事。&lt;/p&gt;

&lt;p&gt;在现阶段项目交付变得越来越难，一方面我们面对众多的需求，做还是不做并不是你能轻易决定的；而另一方面我们又想从架构上解决可以快速满足需求。但本质的是这几个月内，人的技能与意识没有根本性的变化。在大家没有主人翁的精神下，说来说去也是为了需求在垒代码。即使你想从代码结构上重新设计，让系统更松的耦合性，更好的扩展性。受于项目进度冲击，以及代码实现者的被动，最终也会变得让你不想回头多看一眼。
&lt;/p&gt;

&lt;p&gt;编程如果仅仅越考虑短期实现项目需求目的肯定是不好的，但想通过强制的管理手段，或重构手段来想延长它的生命周期也并一定能行得通。当同一份代码是多人开发与维护，并在领导眼中的谁有时间谁就上的话。本意可能是想通过多人的备份，或共同完成以期缩短工期。其实这种做法无疑更是加重了代码朝腐化之路上走的趋势。&lt;/p&gt;

&lt;p&gt;重构有很多的手法或方法理论，其核心都会有提到&lt;code&gt;不改变软件的外部行为&lt;/code&gt;，是对&lt;code&gt;软件内部结构&lt;/code&gt;进行修改与调整。这实际上是非常难以做到的，我们是如何去评估不改变软件的外部行为，充分的测试能保证吗？显然就我们目前的测试能力来看，这简单是非常美好的梦想。尤其是具有一些年头的代码，或者又是人员变化较频繁的代码，看上去并不清爽的代码，至少还能正常的工作，一旦重构不知会丢失多少其中通过各种手段修改出来的小功能点。&lt;/p&gt;

&lt;p&gt;今天的软件交付，可能说由于整体的需求是具有多变性，给软件开发带来不确认性。不确定就会产生怀疑和恐惧，我们经常会说，软件架构是要架构未来，不是解决当下问题。当不确定性还不算太多的时候，我们还在架构层面上来推演，整个软件系统的大致方向可以被预测，然后在此基础上不断地演化。而当不确定性实在太多的时候，对软件的要求就变成了&lt;code&gt;可丢弃&lt;/code&gt;。换句话说，你开发的所有软件，从一开始，你就应该做好很快被丢弃的准备。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;采用开源：尤其是Github让开源的推广与使用变得越来越简单，开源软件在商用软件领域成为了越来越主流。即使你开发的是非常重要的商用软件也不需要自己从头开始，自己实现并一定比开源实现的好。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;平台框架：平台软件的目的是让通用的能力重用与沉淀。业务领域更倾向于采用面向领域的DSL描述简化开发，代码量要求是越来越少。目前各种基础框架越来越成熟，基于基础构架上构建，可以在最短时间内以最少代码量做出一个符合要求的软件。并且业务层不需要过多的设计，因为大部分设计已经蕴含在框架内。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;职责单一：可以把系统拆多功能单一的服务，符合单一职责原则，做且仅做一件事。这样代码量就不会太多，也不需要频繁地添加新的功能，变化少就不不会导致不稳定，所以这样代码烂也烂不到哪里去。另一方面功能单一，在其上的工作团队成员也会很少，四五个人能搞定的代码，它的也不会因为多人的经手变得不可维护。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在面对需要快速迭代交付的项目下，软件开发变得越来越轻量化下。尤其是在微服务架构下，软件开发其实可以不需要重构，该烂的就让它烂掉。对于单个微服务或单个小的模块内的代码重构意义也变得越来越小。如果这个微服务真的到了无法满足需求情况下，那没有必要对它进行重构，重写一个就行了。所以在这样的情况下&lt;code&gt;“重构已死”&lt;/code&gt;，其实又是系统中另外一种&lt;code&gt;“重生”&lt;/code&gt;，就像人的身体一样，做换只手的手术可能影响非常地大，如果只是细胞不断地死去，新的又产生替换，你是感觉不到有什么影响。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>架构重构</title>
      <link>http://lanlingzi.cn/post/technical/2015/0430_arch_refactor/</link>
      <pubDate>Tue, 12 May 2015 00:00:00 +0000</pubDate>
      
      <guid>http://lanlingzi.cn/post/technical/2015/0430_arch_refactor/</guid>
      <description>&lt;p&gt;最近一直在做系统架构上重构工作，理论不能不学习啊，只有在思想上把自己武装起来，才能减少我们工作上的错误。之前参加过或亲自操刀过多次的代码局部或模块重构，但这一次架构重构是范围波及最广，收获颇多。&lt;/p&gt;

&lt;h2 id=&#34;什么是重构&#34;&gt;什么是重构&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;重构是指在不修改代码外在行为的前提下，对代码做出的修改，以改进程序的内部结构，提高其可理解性，降低其修改成本。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这是来自马大神的《重构》一书对重构释义。重构可以改进软件设计；使软件更容易理解；使软件更容易维护；帮助找到软件Bugs；帮助提高编程效率。重构按对系统修改的粒度层次可以分为如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;局部代码重构，操作与实施比较容易，《重构》一书中介绍了大量经典的方法。&lt;/li&gt;
&lt;li&gt;模块级代码重构，可能涉及到模块之间的接口重构，操作与实施难度相对适中。&lt;/li&gt;
&lt;li&gt;架构重构，是对整个系统架构层次的重构，牵系相当的广，操作与实施难度比较高。
&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;重构风险&#34;&gt;重构风险&lt;/h2&gt;

&lt;p&gt;无论何种层次的重构，都必须要有一个可靠的测试环境，即自动化测试环境。因为频繁的代码修改可能会引入更多的缺陷，只有执行自动化测试并回归所有用例，才能保证及时发现这些缺陷，最大限度地降低重构的风险。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;局部的不良代码，可以通过小范围的重构来优化。但是对于架构上重构，因为重构影响范围过大，在实践中仍然存在绪多的困难。&lt;/li&gt;
&lt;li&gt;架构上大的重构，至少几十人的投入，更需要半年到一年的开发周期。在老软件不能停止维护的前提下，这对开发人力将产生巨大冲击。&lt;/li&gt;
&lt;li&gt;新架构虽然先进，但历史经验表明，新软件的成熟与稳定需要时间。在沉重的交付压力下，风险需要做很多的预防控制。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;为什么要重构&#34;&gt;为什么要重构&lt;/h2&gt;

&lt;p&gt;给老大说明重构的意义往往很难，尤其不是技术出身的管理者，即使是，也需要面临交付上的考虑。从技术上讲，为什么要重构：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不论如何先进的软件架构也不可能预见到几年甚至十几年后的需求，并预先设计&lt;/li&gt;
&lt;li&gt;随着新功能的不断增加，以及新成员的加入，软件架构必然逐渐腐化&lt;/li&gt;
&lt;li&gt;虽然强力的架构看护制度可以延缓架构腐化的速度，但不可能看护到实现细节&lt;/li&gt;
&lt;li&gt;重构则提供了软件持续优化的机会，从而使软件更容易适应新的需求，同时及时地改进不合理的部分&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;重构与重写&#34;&gt;重构与重写&lt;/h2&gt;

&lt;p&gt;对于一次重构来说区别不大，只是力度不同，重构侧得局部优化，也会重用现有的资产，重构的极端就是重写。他们的主要区别是重构强调的是持续的，随时的优化，而重写强调的是一次性的天翻地覆的改造。那我们如何判断是要重构还是重写？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;重构是持续的，并不是等到极端恶心才开始优化，所以坚持持续的重构可以代价更小的达到优化的目的&lt;/li&gt;
&lt;li&gt;若已经极端恶化的模块，重写也是一种解决方式，但要注意避免失控，须在设计、测试、管理、人员能力等多方面要做好准备&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;何时重构&#34;&gt;何时重构&lt;/h2&gt;

&lt;p&gt;何时重构，因项目因人员能力而异：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不同粒度层次的重构，重构的时机选择应该是不同的&lt;/li&gt;
&lt;li&gt;不同粒度层次的重构，实施的节奏也必然不同的&lt;/li&gt;
&lt;li&gt;关键技术需要提前原型验证，风险评估&lt;/li&gt;
&lt;li&gt;对于模块级，架构级重构，通常在添加新功能或特性之前充分考虑，留出部分空档期来重构&lt;/li&gt;
&lt;li&gt;制定重构计划，步步为营，切忌全面开花，导致风险不可控&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;同时在重构时，需要平衡重构与交付：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;为了交付而不重构，是恶性循环，最终交付的压力会越来越大，质量会越来越差&lt;/li&gt;
&lt;li&gt;对于模块级，架构级重构，应该是有计划地落入到迭代版本中&lt;/li&gt;
&lt;li&gt;可以采用冬虫夏草的方式重构，逐步重构或替换，随时（至少每个迭代）可以保证系统的完整性&lt;/li&gt;
&lt;li&gt;注意控制每次迭代重构的范围，要分析并划分合理的重构边界&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;重构人员&#34;&gt;重构人员&lt;/h2&gt;

&lt;p&gt;重构最终落实还是人员能力，对于参与的人员能力要求：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;知道重构的意义，重构需要有个人强烈的意愿，才能有所突破&lt;/li&gt;
&lt;li&gt;对现有的组件流程与实现非常地清楚&lt;/li&gt;
&lt;li&gt;针对性强，能够熟练地运用各种重构方法&lt;/li&gt;
&lt;li&gt;能够察觉出实现的问题，能提出改进（重构）建议（方案）&lt;/li&gt;
&lt;li&gt;经验是基础，对构架本身的体系有较为深厚的理解和应用经验&lt;/li&gt;
&lt;li&gt;不同层级的重构，需要不同的参与，不同阶段投入&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;重构中有哪些角色，他们职责是什么&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SA/SE（系统架构师，系统设计师）：负责按照架构正确地设计与分解需求，能清楚系统中的痛点，以及各组件的主要问题&lt;/li&gt;
&lt;li&gt;SE/MDE（系统设计师，模块设计师）：负责某个组件整体看护，设计组件内疗实现机制，系统约束等&lt;/li&gt;
&lt;li&gt;SWE（软件工程师）：在软件架构的基础上，负责具体的功能实现。&lt;/li&gt;
&lt;li&gt;TE（测试工作师）：补充用例，执行自动化测试，及时发现系统中的缺陷，并与SWE结队处理问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;总之，重构要务实，务实就是尊重现实，基于现实情况分析与实施，不断地推进演化。架构重构不仅需要充分的设计，切实有效的重构操作方法也非常地重要。架构重构，抛开代码搞理论上的重构不行；充分利用代码，但又不能掉进“代码泥潭”。无论怎么重构，一定要构建夯实的测试防火墙，快速反馈重构中的问题。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>